# 그리드 알고리즘 완전 가이드

## 목차
1. [기본 개념](#기본-개념)
2. [활동 선택 문제](#활동-선택-문제)
3. [화폐 교환](#화폐-교환)
4. [분수 배낭 문제](#분수-배낭-문제)
5. [구간 스케줄링](#구간-스케줄링)
6. [Huffman 코딩](#huffman-코딩)
7. [최소 신장 트리](#최소-신장-트리)

---

## 기본 개념

**그리드 알고리즘(Greedy Algorithm)**은 매 단계에서 최적의 선택을 하여 최종 최적해를 얻는 알고리즘입니다.

### 특징
- 각 단계에서 가장 좋은 선택을 함
- 이전 선택을 되돌리지 않음
- 모든 문제에 적용 불가 (증명 필요)

### 그리드 알고리즘이 작동하는 조건
1. **그리드스러운 선택 속성**: 전역 최적해가 각 단계의 최적 선택으로 구성
2. **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해 구성

---

## 활동 선택 문제

**시간복잡도**: O(n log n) | **공간복잡도**: O(n)

겹치지 않으면서 최대한 많은 활동을 선택합니다.

### 기본 아이디어
- 가장 먼저 끝나는 활동을 선택
- 그 활동과 겹치지 않는 다음 활동 선택
- 반복

### 구현

```javascript
function activitySelection(activities) {
    /**
     * activities: [[start, end], ...] 형태
     * 끝나는 시간으로 정렬됨
     */
    if (activities.length === 0) {
        return [];
    }
    
    // 끝나는 시간으로 정렬
    activities.sort((a, b) => a[1] - b[1]);
    
    const selected = [activities[0]];
    let lastEnd = activities[0][1];
    
    for (let i = 1; i < activities.length; i++) {
        const [start, end] = activities[i];
        // 시작 시간이 마지막 활동의 끝 시간 이후면 선택 가능
        if (start >= lastEnd) {
            selected.push([start, end]);
            lastEnd = end;
        }
    }
    
    return selected;
}

// 예시
const activities = [[1, 3], [2, 5], [4, 6], [6, 8], [5, 7], [8, 9]];
console.log(activitySelection(activities));
// [[1, 3], [4, 6], [8, 9]]
```

### 최대 선택 개수만 구하기

```javascript
function maxActivities(activities) {
    activities.sort((a, b) => a[1] - b[1]);
    let count = 1;
    let lastEnd = activities[0][1];
    
    for (let i = 1; i < activities.length; i++) {
        if (activities[i][0] >= lastEnd) {
            count++;
            lastEnd = activities[i][1];
        }
    }
    
    return count;
}

// 예시
const activities = [[1, 3], [2, 5], [4, 6], [6, 8], [5, 7], [8, 9]];
console.log(maxActivities(activities));  // 3
```

---

## 화폐 교환

**시간복잡도**: O(n) | **공간복잡도**: O(1)

특정 금액을 동전으로 만드는 최소 개수를 구합니다.

### 기본 구현

```javascript
function coinChangeGreedy(coins, amount) {
    /**
     * coins: 내림차순으로 정렬된 동전 단위
     * amount: 만들어야 할 금액
     */
    coins.sort((a, b) => b - a);
    let count = 0;
    let remaining = amount;
    
    for (const coin of coins) {
        count += Math.floor(remaining / coin);
        remaining %= coin;
    }
    
    return remaining === 0 ? count : -1;
}

// 예시 - 작동함
const coins = [50, 20, 10, 5, 1];
console.log(coinChangeGreedy(coins, 48));  // 5
```

### 그리드가 작동하는 조건

표준 동전 시스템 (1, 5, 10, 25 등):
- 각 동전이 이전 동전의 배수 관계

```javascript
function isCanonicalCoinSystem(coins) {
    /**
     * 그리드 알고리즘이 작동하는 동전 시스템인지 확인
     */
    coins.sort((a, b) => a - b);
    if (coins[0] !== 1) {
        return false;
    }
    
    return true;
}

// 예시
const coins = [1, 5, 10, 25];
console.log(isCanonicalCoinSystem(coins));  // true
```

---

## 분수 배낭 문제

**시간복잡도**: O(n log n) | **공간복잡도**: O(n)

각 물건을 쪼갤 수 있는 배낭 문제입니다.

### 구현

```javascript
function fractionalKnapsack(items, capacity) {
    /**
     * items: [[value, weight], ...] 형태
     * capacity: 배낭 용량
     */
    // 단위 무게당 가치로 정렬
    items.sort((a, b) => (b[0] / b[1]) - (a[0] / a[1]));
    
    let totalValue = 0.0;
    
    for (const [value, weight] of items) {
        if (capacity >= weight) {
            // 물건 전체를 넣을 수 있음
            totalValue += value;
            capacity -= weight;
        } else {
            // 물건을 쪼개서 넣음
            totalValue += value * (capacity / weight);
            break;
        }
    }
    
    return totalValue;
}

// 예시
const items = [[60, 10], [100, 20], [120, 30]];
const capacity = 50;
console.log(fractionalKnapsack(items, capacity));  // 240.0
```

### 선택된 물건 추적

```javascript
function fractionalKnapsackWithItems(items, capacity) {
    items.sort((a, b) => (b[0] / b[1]) - (a[0] / a[1]));
    
    let totalValue = 0.0;
    const selected = [];
    
    for (let i = 0; i < items.length; i++) {
        const [value, weight] = items[i];
        if (capacity >= weight) {
            totalValue += value;
            selected.push([i, weight, value]);
            capacity -= weight;
        } else {
            const fraction = capacity / weight;
            totalValue += value * fraction;
            selected.push([i, capacity, value * fraction]);
            break;
        }
    }
    
    return [totalValue, selected];
}

// 예시
const items = [[60, 10], [100, 20], [120, 30]];
const capacity = 50;
const [value, selected] = fractionalKnapsackWithItems(items, capacity);
console.log(`최대 가치: ${value}`);
console.log(`선택된 물건: ${JSON.stringify(selected)}`);
```

---

## 구간 스케줄링

### 최대 가중 구간 스케줄링

각 구간에 가중치가 있을 때 최대 가중치 선택:

```javascript
function weightedIntervalScheduling(intervals) {
    /**
     * intervals: [[start, end, weight], ...] 형태
     * 동적 프로그래밍 필요 (그리드 불가)
     */
    intervals.sort((a, b) => a[1] - b[1]);
    const n = intervals.length;
    const dp = new Array(n + 1).fill(0);
    
    for (let i = 1; i <= n; i++) {
        // i번째 구간을 선택하지 않는 경우
        const notTake = dp[i - 1];
        
        // i번째 구간을 선택하는 경우
        let take = intervals[i - 1][2];
        
        // i번째 구간과 겹치지 않는 가장 최근 구간 찾기
        let j = i - 2;
        while (j >= 0 && intervals[j][1] > intervals[i - 1][0]) {
            j--;
        }
        
        if (j >= 0) {
            take += dp[j + 1];
        }
        
        dp[i] = Math.max(notTake, take);
    }
    
    return dp[n];
}

// 예시
const intervals = [[1, 3, 5], [2, 5, 6], [4, 6, 5], [6, 8, 4], [5, 7, 4]];
console.log(weightedIntervalScheduling(intervals));
```

---

## Huffman 코딩

**시간복잡도**: O(n log n) | **공간복잡도**: O(n)

문자의 빈도에 따라 최적의 접두사 없는 코드를 생성합니다.

### 노드 클래스

```javascript
class Node {
    constructor(freq, char = null, left = null, right = null) {
        this.freq = freq;
        this.char = char;
        this.left = left;
        this.right = right;
    }
}
```

### Huffman 트리 구성

```javascript
function huffmanCoding(text) {
    // 빈도 계산
    const freq = {};
    for (const char of text) {
        freq[char] = (freq[char] || 0) + 1;
    }
    
    // 우선순위 큐 생성 (최소 힙)
    const heap = Object.entries(freq).map(([char, f]) => new Node(f, char));
    heap.sort((a, b) => a.freq - b.freq);
    
    // 트리 구성
    while (heap.length > 1) {
        heap.sort((a, b) => a.freq - b.freq);
        const left = heap.shift();
        const right = heap.shift();
        const parent = new Node(left.freq + right.freq, null, left, right);
        heap.push(parent);
    }
    
    const root = heap[0];
    
    // 코드 생성
    const codes = {};
    function generateCodes(node, code = '') {
        if (!node) return;
        if (node.char) {
            codes[node.char] = code || '0';
        } else {
            generateCodes(node.left, code + '0');
            generateCodes(node.right, code + '1');
        }
    }
    
    generateCodes(root);
    
    // 인코딩
    const encoded = text.split('').map(c => codes[c]).join('');
    
    return [codes, encoded];
}

// 예시
const text = "hello world";
const [codes, encoded] = huffmanCoding(text);
console.log(`코드:`, codes);
console.log(`인코딩됨:`, encoded);
console.log(`압축률: ${(encoded.length / (text.length * 8) * 100).toFixed(1)}%`);
```

---

## 최소 신장 트리

크루스칼과 프림 알고리즘도 그리드 알고리즘입니다.

### 크루스칼 (간선 기반)

```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({length: n}, (_, i) => i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const px = this.find(x);
        const py = this.find(y);
        if (px === py) {
            return false;
        }
        if (this.rank[px] < this.rank[py]) {
            [px, py] = [py, px];
        }
        this.parent[py] = px;
        if (this.rank[px] === this.rank[py]) {
            this.rank[px]++;
        }
        return true;
    }
}

function kruskal(n, edges) {
    edges.sort((a, b) => a[0] - b[0]);
    const uf = new UnionFind(n);
    const mst = [];
    
    for (const [weight, u, v] of edges) {
        if (uf.union(u, v)) {
            mst.push([u, v, weight]);
        }
    }
    
    return mst;
}

// 예시
const edges = [[1, 0, 1], [2, 0, 2], [4, 1, 2], [5, 1, 3], [8, 2, 3], [10, 2, 4], [2, 3, 4]];
const mst = kruskal(5, edges);
console.log(mst);
```

---

## 그리드 알고리즘 체크리스트

탐욕 알고리즘이 최적해를 보장하는지 확인:

1. **그리드 선택의 증명**
   - 전역 최적해가 그리드 선택을 포함하는가?

2. **최적 부분 구조 증명**
   - 부분 문제의 최적해가 전체 최적해를 구성하는가?

3. **반례 찾기**
   - 그리드가 실패하는 경우가 있는가?

---

## 자주 묻는 그리드 문제

1. **활동 선택**: 최대 개수 활동 선택
2. **구간 분할**: 최소 분할 수
3. **작업 스케줄링**: 최대 이익
4. **최소 신장 트리**: 최소 비용
5. **허프만 코딩**: 최적 인코딩
6. **분수 배낭**: 최대 가치
7. **거스름돈**: 최소 동전 개수

