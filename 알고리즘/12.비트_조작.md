# 비트 조작 완전 가이드

## 목차
1. [기본 비트 연산](#기본-비트-연산)
2. [비트 마스킹](#비트-마스킹)
3. [비트 연산의 활용](#비트-연산의-활용)
4. [고급 기법](#고급-기법)

---

## 기본 비트 연산

### AND (&)

```javascript
// 특정 비트 확인
function getBit(num, i) {
    /**i번째 비트가 1인지 확인*/
    return (num >> i) & 1;
}

// 예시
const num = 5;  // 0101
console.log(getBit(num, 0));  // 1
console.log(getBit(num, 1));  // 0
console.log(getBit(num, 2));  // 1
```

### OR (|)

```javascript
// 특정 비트를 1로 설정
function setBit(num, i) {
    /**i번째 비트를 1로 설정*/
    return num | (1 << i);
}

// 예시
const num = 5;  // 0101
console.log(setBit(num, 1));  // 7 (0111)
console.log((setBit(num, 1)).toString(2));  // 0b111
```

### XOR (^)

```javascript
// XOR의 성질: a ^ a = 0, a ^ 0 = a, a ^ b ^ a = b
function toggleBit(num, i) {
    /**i번째 비트를 뒤집기 (0->1, 1->0)*/
    return num ^ (1 << i);
}

// 예시
const num = 5;  // 0101
console.log(toggleBit(num, 0));  // 4 (0100)
console.log(toggleBit(num, 1));  // 7 (0111)
```

### NOT (~)

```javascript
// 모든 비트를 반전 (부호도 변함)
const num = 5;  // 0101
console.log(~num);  // -6
```

### 시프트 연산

```javascript
// 왼쪽 시프트: 2를 곱함
console.log(5 << 1);  // 10 (0101 -> 1010)
console.log(5 << 2);  // 20 (0101 -> 10100)

// 오른쪽 시프트: 2로 나눔 (정수 나눗셈)
console.log(5 >> 1);  // 2 (0101 -> 010)
console.log(5 >> 2);  // 1 (0101 -> 01)
```

---

## 비트 마스킹

### 1. 비트 테이블 조작

```javascript
// 비트마스크로 집합 표현 (작은 범위에서 공간 절약)
function addToSet(mask, i) {
    /**집합에 i 추가*/
    return mask | (1 << i);
}

function removeFromSet(mask, i) {
    /**집합에서 i 제거*/
    return mask & ~(1 << i);
}

function contains(mask, i) {
    /**집합이 i를 포함하는지 확인*/
    return ((mask >> i) & 1) === 1;
}

function toggleInSet(mask, i) {
    /**집합에서 i의 포함 여부 토글*/
    return mask ^ (1 << i);
}

// 예시
let mask = 0;
mask = addToSet(mask, 1);
mask = addToSet(mask, 3);
console.log(mask.toString(2));  // 1010
console.log(contains(mask, 1));  // true
console.log(contains(mask, 2));  // false
```

### 2. 부분집합 생성

```javascript
function generateSubsets(arr) {
    /**배열의 모든 부분집합 생성*/
    const n = arr.length;
    const subsets = [];
    
    for (let mask = 0; mask < (1 << n); mask++) {
        const subset = [];
        for (let i = 0; i < n; i++) {
            if ((mask & (1 << i)) !== 0) {
                subset.push(arr[i]);
            }
        }
        subsets.push(subset);
    }
    
    return subsets;
}

// 예시
const arr = [1, 2, 3];
const subsets = generateSubsets(arr);
for (const subset of subsets) {
    console.log(subset);
}
// []
// [1]
// [2]
// [1, 2]
// [3]
// [1, 3]
// [2, 3]
// [1, 2, 3]
```

---

## 비트 연산의 활용

### 1. 중복 제거 (XOR)

```javascript
function findSingleNumber(arr) {
    /**
     * 배열에서 한 번만 나타나는 수 찾기
     * 나머지는 두 번씩 나타남
     * XOR: a ^ a = 0, a ^ 0 = a
     */
    let result = 0;
    for (const num of arr) {
        result ^= num;
    }
    return result;
}

// 예시
const arr = [1, 1, 2, 2, 3, 3, 4];
console.log(findSingleNumber(arr));  // 4
```

### 2. 누락된 수 찾기

```javascript
function findMissingNumber(arr, n) {
    /**1부터 n까지의 수 중 누락된 수 찾기*/
    let xorResult = 0;
    
    // 배열의 모든 수 XOR
    for (const num of arr) {
        xorResult ^= num;
    }
    
    // 1부터 n까지 XOR
    for (let i = 1; i <= n; i++) {
        xorResult ^= i;
    }
    
    return xorResult;
}

// 예시
const arr = [1, 2, 4, 5, 6];
console.log(findMissingNumber(arr, 6));  // 3
```

### 3. 2의 거듭제곱 확인

```javascript
function isPowerOfTwo(n) {
    /**n이 2의 거듭제곱인지 확인*/
    return n > 0 && (n & (n - 1)) === 0;
}

// 예시
console.log(isPowerOfTwo(16));  // true
console.log(isPowerOfTwo(18));  // false
console.log(isPowerOfTwo(1));   // true (2^0)
```

### 4. 비트 개수 세기

```javascript
function countSetBits(n) {
    /**정수 n의 1 비트 개수*/
    let count = 0;
    while (n) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}

// Python 내장 함수
function countSetBitsBuiltin(n) {
    return n.toString(2).split('').filter(bit => bit === '1').length;
}

// Brian Kernighan's Algorithm (더 빠름)
function countSetBitsFast(n) {
    let count = 0;
    while (n) {
        n &= (n - 1);  // 가장 오른쪽 1 제거
        count++;
    }
    return count;
}

// 예시
console.log(countSetBits(13));  // 3 (1101)
console.log(countSetBitsBuiltin(13));  // 3
console.log(countSetBitsFast(13));  // 3
```

### 5. 2의 거듭제곱으로 올림

```javascript
function nextPowerOfTwo(n) {
    /**n 이상의 최소 2의 거듭제곱*/
    if (n === 0) {
        return 1;
    }
    if (isPowerOfTwo(n)) {
        return n;
    }
    
    // 비트를 오른쪽으로 시프트하며 모든 비트를 1로 만들기
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    
    return n + 1;
}

// 예시
console.log(nextPowerOfTwo(5));   // 8
console.log(nextPowerOfTwo(16));  // 16
console.log(nextPowerOfTwo(17));  // 32
```

---

## 고급 기법

### 1. 최하위 설정 비트

```javascript
function getLowestSetBit(n) {
    /**최하위 1 비트 값 구하기*/
    return n & -n;
}

// 예시
const n = 12;  // 1100
console.log(getLowestSetBit(n));  // 4 (0100)
console.log(getLowestSetBit(n).toString(2));  // 0b100
```

### 2. 비트 순열

```javascript
function reverseBits(n, bits = 32) {
    /**비트 역순*/
    let result = 0;
    for (let i = 0; i < bits; i++) {
        result = (result << 1) | (n & 1);
        n >>= 1;
    }
    return result;
}

// 예시
const n = 6;  // 00110
console.log(reverseBits(n, 5));  // 6 (01100 -> 00110)
```

### 3. 그레이 코드 변환

```javascript
function binaryToGray(n) {
    /**이진 코드를 그레이 코드로*/
    return n ^ (n >> 1);
}

function grayToBinary(n) {
    /**그레이 코드를 이진 코드로*/
    let result = n;
    while (n) {
        n >>= 1;
        result ^= n;
    }
    return result;
}

// 예시
for (let i = 0; i < 8; i++) {
    const gray = binaryToGray(i);
    console.log(`${i.toString(2).padStart(3, '0')} -> ${gray.toString(2).padStart(3, '0')}`);
}
// 000 -> 000
// 001 -> 001
// 010 -> 011
// 011 -> 010
// 100 -> 110
// 101 -> 111
// 110 -> 101
// 111 -> 100
```

### 4. 빠른 거듭제곱

```javascript
function fastPower(base, exp, mod = null) {
    /**빠른 거듭제곱 계산 (분할 정복 방식)*/
    let result = 1;
    base = mod ? base % mod : base;
    
    while (exp > 0) {
        if (exp & 1) {
            result = result * base;
            if (mod) {
                result %= mod;
            }
        }
        exp >>= 1;
        base = base * base;
        if (mod) {
            base %= mod;
        }
    }
    
    return result;
}

// 예시
console.log(fastPower(2, 10));  // 1024
console.log(fastPower(2, 100, 1000000007));
```

---

## 자주 나오는 비트 문제

1. **중복 제거**: XOR 활용
2. **비트 개수**: Set bit counting
3. **부분집합**: 비트마스킹
4. **동적 프로그래밍**: TSP, 최대 독립 집합
5. **거듭제곱**: 분할 정복
6. **2진 변환**: 그레이 코드, 역순
7. **최적화**: 메모리 절약, 빠른 계산

---

## 비트 연산 팁

```javascript
// 자주 사용하는 패턴들

// 1. i번째 비트 확인
if (((n >> i) & 1) === 1) {
    console.log("bit set");
}

// 2. i번째 비트 설정
n |= (1 << i);

// 3. i번째 비트 해제
n &= ~(1 << i);

// 4. i번째 비트 토글
n ^= (1 << i);

// 5. 모든 비트가 1인지 확인
if ((n & (n + 1)) === 0) {
    console.log("all bits set");
}

// 6. 가장 오른쪽 설정 비트만 남기기
const rightmost = n & (-n);

// 7. 가장 오른쪽 설정 비트 제거
n &= (n - 1);

// 8. 비트 개수
const popcount = n.toString(2).split('').filter(bit => bit === '1').length;
```

---

## 비트 마스크를 사용한 부분집합 합

```javascript
function subsetSum(arr, target) {
    /**
     * 부분집합의 합이 target인 경우가 있는지 확인
     */
    const n = arr.length;
    // dp[i][j] = arr[0...i-1]로 합 j를 만들 수 있는가
    const dp = Array(n + 1).fill(0).map(() => Array(target + 1).fill(false));
    
    // 합이 0인 경우는 항상 가능 (공집합)
    for (let i = 0; i <= n; i++) {
        dp[i][0] = true;
    }
    
    for (let i = 1; i <= n; i++) {
        for (let j = 0; j <= target; j++) {
            // arr[i-1]을 선택하지 않는 경우
            dp[i][j] = dp[i - 1][j];
            
            // arr[i-1]을 선택하는 경우
            if (j >= arr[i - 1]) {
                dp[i][j] = dp[i][j] || dp[i - 1][j - arr[i - 1]];
            }
        }
    }
    
    return dp[n][target];
}

// 예시
const arr = [3, 34, 4, 12, 5, 2];
const target = 9;
console.log(subsetSum(arr, target));  // true (4+5 또는 4+3+2)
```

