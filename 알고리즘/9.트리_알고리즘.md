# 트리 알고리즘 완전 가이드

## 목차
1. [기본 개념](#기본-개념)
2. [트리 순회](#트리-순회)
3. [최소 공통 조상](#최소-공통-조상-lca)
4. [트리 높이와 균형](#트리-높이와-균형)
5. [세그먼트 트리](#세그먼트-트리)
6. [이진 탐색 트리](#이진-탐색-트리)

---

## 기본 개념

### 트리 노드 구조

```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class GeneralTreeNode {
    constructor(value) {
        this.value = value;
        this.children = [];
    }
}
```

---

## 트리 순회

**시간복잡도**: O(n) | **공간복잡도**: O(h) (h는 높이)

### 전위 순회 (Preorder: Root-Left-Right)

```javascript
// 재귀
function preorderRecursive(node) {
    if (!node) {
        return [];
    }
    const result = [node.value];
    result.push(...preorderRecursive(node.left));
    result.push(...preorderRecursive(node.right));
    return result;
}

// 반복 (스택)
function preorderIterative(root) {
    if (!root) {
        return [];
    }
    const result = [];
    const stack = [root];
    while (stack.length) {
        const node = stack.pop();
        result.push(node.value);
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }
    return result;
}
```

### 중위 순회 (Inorder: Left-Root-Right)

BST에서 오름차순으로 출력됩니다.

```javascript
// 재귀
function inorderRecursive(node) {
    if (!node) {
        return [];
    }
    const result = [];
    result.push(...inorderRecursive(node.left));
    result.push(node.value);
    result.push(...inorderRecursive(node.right));
    return result;
}

// 반복 (스택)
function inorderIterative(root) {
    const result = [];
    const stack = [];
    let current = root;
    
    while (current || stack.length) {
        while (current) {
            stack.push(current);
            current = current.left;
        }
        current = stack.pop();
        result.push(current.value);
        current = current.right;
    }
    
    return result;
}
```

### 후위 순회 (Postorder: Left-Right-Root)

```javascript
// 재귀
function postorderRecursive(node) {
    if (!node) {
        return [];
    }
    const result = [];
    result.push(...postorderRecursive(node.left));
    result.push(...postorderRecursive(node.right));
    result.push(node.value);
    return result;
}

// 반복 (스택 2개)
function postorderIterative(root) {
    if (!root) {
        return [];
    }
    
    const result = [];
    const stack1 = [root];
    const stack2 = [];
    
    while (stack1.length) {
        const node = stack1.pop();
        stack2.push(node);
        if (node.left) stack1.push(node.left);
        if (node.right) stack1.push(node.right);
    }
    
    while (stack2.length) {
        result.push(stack2.pop().value);
    }
    
    return result;
}
```

### 레벨 순회 (Level Order - BFS)

```javascript
function levelOrder(root) {
    if (!root) {
        return [];
    }
    
    const result = [];
    const queue = [root];
    
    while (queue.length) {
        const levelSize = queue.length;
        const level = [];
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            level.push(node.value);
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        result.push(level);
    }
    
    return result;
}
```

---

## 최소 공통 조상 (LCA)

### 이진 탐색 트리에서의 LCA

**시간복잡도**: O(h) | **공간복잡도**: O(1)

```javascript
function findLCABST(root, p, q) {
    /**BST에서 두 노드의 최소 공통 조상 찾기*/
    if (!root) {
        return null;
    }
    
    // p와 q가 모두 왼쪽에 있으면 왼쪽으로
    if (p.value < root.value && q.value < root.value) {
        return findLCABST(root.left, p, q);
    }
    // p와 q가 모두 오른쪽에 있으면 오른쪽으로
    else if (p.value > root.value && q.value > root.value) {
        return findLCABST(root.right, p, q);
    }
    // 현재 노드가 LCA
    return root;
}
```

### 일반 이진 트리에서의 LCA

```javascript
function findLCA(root, p, q) {
    /**일반 이진 트리에서 LCA 찾기*/
    if (!root) {
        return null;
    }
    
    if (root === p || root === q) {
        return root;
    }
    
    const left = findLCA(root.left, p, q);
    const right = findLCA(root.right, p, q);
    
    if (left && right) {
        return root;
    }
    return left || right;
}
```

---

## 트리 높이와 균형

```javascript
function treeHeight(node) {
    /**트리의 높이 계산*/
    if (!node) {
        return 0;
    }
    return 1 + Math.max(treeHeight(node.left), treeHeight(node.right));
}

function isBalanced(node) {
    /**이진 트리가 균형잡혀있는지 확인*/
    if (!node) {
        return true;
    }
    
    const leftHeight = treeHeight(node.left);
    const rightHeight = treeHeight(node.right);
    
    if (Math.abs(leftHeight - rightHeight) > 1) {
        return false;
    }
    
    return isBalanced(node.left) && isBalanced(node.right);
}

// 최적화 버전
function isBalancedOptimized(node) {
    /**높이를 한 번에 계산하며 확인*/
    function check(node) {
        if (!node) {
            return [true, 0];
        }
        
        const [leftBalanced, leftHeight] = check(node.left);
        if (!leftBalanced) {
            return [false, 0];
        }
        
        const [rightBalanced, rightHeight] = check(node.right);
        if (!rightBalanced) {
            return [false, 0];
        }
        
        const balanced = Math.abs(leftHeight - rightHeight) <= 1;
        const height = 1 + Math.max(leftHeight, rightHeight);
        
        return [balanced, height];
    }
    
    return check(node)[0];
}
```

---

## 세그먼트 트리

**시간복잡도**: 구성 O(n), 쿼리/업데이트 O(log n) | **공간복잡도**: O(n)

```javascript
class SegmentTree {
    constructor(arr) {
        this.n = arr.length;
        this.tree = new Array(4 * this.n).fill(0);
        this.build(arr, 0, 0, this.n - 1);
    }
    
    build(arr, node, start, end) {
        /**세그먼트 트리 구성*/
        if (start === end) {
            this.tree[node] = arr[start];
        } else {
            const mid = Math.floor((start + end) / 2);
            const leftChild = 2 * node + 1;
            const rightChild = 2 * node + 2;
            
            this.build(arr, leftChild, start, mid);
            this.build(arr, rightChild, mid + 1, end);
            
            this.tree[node] = this.tree[leftChild] + this.tree[rightChild];
        }
    }
    
    query(node, start, end, left, right) {
        /**범위 합 쿼리*/
        if (right < start || end < left) {
            return 0;
        }
        
        if (left <= start && end <= right) {
            return this.tree[node];
        }
        
        const mid = Math.floor((start + end) / 2);
        const leftChild = 2 * node + 1;
        const rightChild = 2 * node + 2;
        
        const leftSum = this.query(leftChild, start, mid, left, right);
        const rightSum = this.query(rightChild, mid + 1, end, left, right);
        
        return leftSum + rightSum;
    }
    
    update(node, start, end, idx, value) {
        /**포인트 업데이트*/
        if (start === end) {
            this.tree[node] = value;
        } else {
            const mid = Math.floor((start + end) / 2);
            const leftChild = 2 * node + 1;
            const rightChild = 2 * node + 2;
            
            if (idx <= mid) {
                this.update(leftChild, start, mid, idx, value);
            } else {
                this.update(rightChild, mid + 1, end, idx, value);
            }
            
            this.tree[node] = this.tree[leftChild] + this.tree[rightChild];
        }
    }
    
    rangeQuery(left, right) {
        /**사용자 인터페이스 - 범위 쿼리*/
        return this.query(0, 0, this.n - 1, left, right);
    }
    
    pointUpdate(idx, value) {
        /**사용자 인터페이스 - 포인트 업데이트*/
        this.update(0, 0, this.n - 1, idx, value);
    }
}

// 예시
const arr = [1, 3, 5, 7, 9, 11];
const st = new SegmentTree(arr);
console.log(st.rangeQuery(1, 5));  // 3+5+7+9+11 = 35
st.pointUpdate(2, 10);  // arr[2] = 10으로 변경
console.log(st.rangeQuery(1, 5));  // 3+10+7+9+11 = 40
```

---

## 이진 탐색 트리

```javascript
class BST {
    constructor() {
        this.root = null;
    }
    
    insert(value) {
        if (!this.root) {
            this.root = new TreeNode(value);
        } else {
            this._insertRecursive(this.root, value);
        }
    }
    
    _insertRecursive(node, value) {
        if (value < node.value) {
            if (!node.left) {
                node.left = new TreeNode(value);
            } else {
                this._insertRecursive(node.left, value);
            }
        } else {
            if (!node.right) {
                node.right = new TreeNode(value);
            } else {
                this._insertRecursive(node.right, value);
            }
        }
    }
    
    search(value) {
        return this._searchRecursive(this.root, value);
    }
    
    _searchRecursive(node, value) {
        if (!node) {
            return false;
        }
        if (node.value === value) {
            return true;
        } else if (value < node.value) {
            return this._searchRecursive(node.left, value);
        } else {
            return this._searchRecursive(node.right, value);
        }
    }
    
    delete(value) {
        this.root = this._deleteRecursive(this.root, value);
    }
    
    _deleteRecursive(node, value) {
        if (!node) {
            return null;
        }
        
        if (value < node.value) {
            node.left = this._deleteRecursive(node.left, value);
        } else if (value > node.value) {
            node.right = this._deleteRecursive(node.right, value);
        } else {
            if (!node.left) {
                return node.right;
            } else if (!node.right) {
                return node.left;
            } else {
                const minLargerNode = this._findMin(node.right);
                node.value = minLargerNode.value;
                node.right = this._deleteRecursive(node.right, minLargerNode.value);
            }
        }
        
        return node;
    }
    
    _findMin(node) {
        while (node.left) {
            node = node.left;
        }
        return node;
    }
}
```

---

## 자주 나오는 트리 문제

1. **순회**: Preorder, Inorder, Postorder, Level Order
2. **경로**: 루트에서 리프까지, 두 노드 사이
3. **LCA**: 최소 공통 조상 찾기
4. **균형**: AVL, 레드-블랙 트리
5. **세그먼트**: 범위 쿼리
6. **BST**: 검색, 삽입, 삭제

