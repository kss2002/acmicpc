# 그래프 알고리즘 완전 가이드

## 목차
1. [최단 경로 - 다익스트라](#다익스트라-dijkstra)
2. [최단 경로 - 벨만-포드](#벨만-포드-bellman-ford)
3. [최단 경로 - 플로이드-와샬](#플로이드-와샬-floyd-warshall)
4. [최소 신장 트리 - 크루스칼](#크루스칼-kruskal)
5. [최소 신장 트리 - 프림](#프림-prim)
6. [위상 정렬](#위상-정렬-topological-sort)
7. [강한 연결 요소](#강한-연결-요소-scc)

---

## 다익스트라 (Dijkstra)

**시간복잡도**: O((V + E) log V) 우선순위큐 사용 | **공간복잡도**: O(V)

음이 아닌 간선 가중치에서 한 노드에서 다른 모든 노드까지의 최단 경로를 찾습니다.

### 기본 구현

```javascript
function dijkstra(graph, start) {
    // graph는 {node: [[neighbor, weight], ...]}
    const distances = {};
    const visited = new Set();
    const pq = [[0, start]];
    
    for (const node in graph) {
        distances[node] = Infinity;
    }
    distances[start] = 0;
    
    while (pq.length > 0) {
        pq.sort((a, b) => a[0] - b[0]);
        const [currentDist, currentNode] = pq.shift();
        
        if (visited.has(currentNode)) continue;
        visited.add(currentNode);
        
        if (currentDist > distances[currentNode]) continue;
        
        for (const [neighbor, weight] of graph[currentNode]) {
            const distance = currentDist + weight;
            
            if (distance < distances[neighbor]) {
                distances[neighbor] = distance;
                pq.push([distance, neighbor]);
            }
        }
    }
    
    return distances;
}

// 예시
const graph = {
    'A': [['B', 4], ['C', 2]],
    'B': [['C', 1], ['D', 5]],
    'C': [['D', 8], ['E', 10]],
    'D': [['E', 2]],
    'E': []
};
console.log(dijkstra(graph, 'A'));
// {'A': 0, 'B': 4, 'C': 2, 'D': 8, 'E': 10}
```

### 최단 경로 재구성

```javascript
function dijkstraWithPath(graph, start, end) {
    const distances = {};
    const previous = {};
    const visited = new Set();
    const pq = [[0, start]];
    
    for (const node in graph) {
        distances[node] = Infinity;
        previous[node] = null;
    }
    distances[start] = 0;
    
    while (pq.length > 0) {
        pq.sort((a, b) => a[0] - b[0]);
        const [currentDist, currentNode] = pq.shift();
        
        if (visited.has(currentNode)) continue;
        visited.add(currentNode);
        
        for (const [neighbor, weight] of graph[currentNode]) {
            const distance = currentDist + weight;
            
            if (distance < distances[neighbor]) {
                distances[neighbor] = distance;
                previous[neighbor] = currentNode;
                pq.push([distance, neighbor]);
            }
        }
    }
    
    // 경로 복원
    const path = [];
    let current = end;
    while (current !== null) {
        path.unshift(current);
        current = previous[current];
    }
    
    return [distances[end], path];
}

// 예시
const [distance, path] = dijkstraWithPath(graph, 'A', 'E');
console.log(`거리: ${distance}, 경로: ${path.join(' -> ')}`);
```

---

## 벨만-포드 (Bellman-Ford)

**시간복잡도**: O(VE) | **공간복잡도**: O(V)

음의 간선이 있어도 최단 경로를 찾을 수 있습니다. 음의 순환 감지 가능합니다.

```javascript
function bellmanFord(edges, numNodes, start) {
    // edges는 [from, to, weight] 형태
    const distances = new Array(numNodes).fill(Infinity);
    distances[start] = 0;
    
    // V-1번 반복
    for (let _ = 0; _ < numNodes - 1; _++) {
        for (const [u, v, weight] of edges) {
            if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
                distances[v] = distances[u] + weight;
            }
        }
    }
    
    // 음의 순환 감지
    for (const [u, v, weight] of edges) {
        if (distances[u] !== Infinity && distances[u] + weight < distances[v]) {
            return null;  // 음의 순환 존재
        }
    }
    
    return distances;
}

// 예시
const edges = [
    [0, 1, 4],
    [0, 2, 2],
    [1, 2, 1],
    [1, 3, 5],
    [2, 3, 8],
    [2, 4, 10],
    [3, 4, 2]
];
console.log(bellmanFord(edges, 5, 0));
// [0, 4, 2, 9, 11]
```

---

## 플로이드-와샬 (Floyd-Warshall)

**시간복잡도**: O(V³) | **공간복잡도**: O(V²)

모든 쌍의 최단 경로를 구합니다. 작은 그래프에서 유용합니다.

```javascript
function floydWarshall(graph, numNodes) {
    const INF = Infinity;
    const dist = Array(numNodes).fill(0).map(() => Array(numNodes).fill(INF));
    
    // 초기화
    for (let i = 0; i < numNodes; i++) {
        dist[i][i] = 0;
    }
    
    for (const [u, v, weight] of graph) {
        dist[u][v] = weight;
    }
    
    // 중간 노드 k를 거쳐서 가는 경로 확인
    for (let k = 0; k < numNodes; k++) {
        for (let i = 0; i < numNodes; i++) {
            for (let j = 0; j < numNodes; j++) {
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
    
    return dist;
}

// 예시
const edges = [
    [0, 1, 4],
    [0, 2, 2],
    [1, 2, 1],
    [1, 3, 5],
    [2, 3, 8],
    [2, 4, 10],
    [3, 4, 2]
];
const result = floydWarshall(edges, 5);
```

---

## 크루스칼 (Kruskal)

**시간복잡도**: O(E log E) | **공간복잡도**: O(V)

간선을 가중치 순으로 정렬하여 사이클을 만들지 않게 추가합니다.

### Union-Find 구조

```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({length: n}, (_, i) => i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);  // 경로 압축
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const px = this.find(x);
        const py = this.find(y);
        if (px === py) {
            return false;
        }
        
        // 랭크로 합치기
        if (this.rank[px] < this.rank[py]) {
            [px, py] = [py, px];
        }
        
        this.parent[py] = px;
        if (this.rank[px] === this.rank[py]) {
            this.rank[px]++;
        }
        
        return true;
    }
}
```

### 크루스칼 알고리즘

```javascript
function kruskal(numNodes, edges) {
    // edges는 [weight, u, v] 형태
    edges.sort((a, b) => a[0] - b[0]);
    const uf = new UnionFind(numNodes);
    const mst = [];
    let totalWeight = 0;
    
    for (const [weight, u, v] of edges) {
        if (uf.union(u, v)) {
            mst.push([u, v, weight]);
            totalWeight += weight;
        }
    }
    
    return [mst, totalWeight];
}

// 예시
const edges = [
    [4, 0, 1],
    [2, 0, 2],
    [1, 1, 2],
    [5, 1, 3],
    [8, 2, 3],
    [10, 2, 4],
    [2, 3, 4]
];
const [mst, total] = kruskal(5, edges);
console.log(`MST: ${JSON.stringify(mst)}, 총 가중치: ${total}`);
```

---

## 프림 (Prim)

**시간복잡도**: O((V + E) log V) | **공간복잡도**: O(V)

시작 노드에서 시작하여 가장 가까운 노드를 계속 추가합니다.

```javascript
function prim(graph, start) {
    const visited = new Set([start]);
    const edges = [];
    const mst = [];
    let totalWeight = 0;
    
    for (const [neighbor, weight] of graph[start]) {
        edges.push([weight, start, neighbor]);
    }
    
    while (edges.length > 0) {
        edges.sort((a, b) => a[0] - b[0]);
        const [weight, u, v] = edges.shift();
        
        if (visited.has(v)) continue;
        
        visited.add(v);
        mst.push([u, v, weight]);
        totalWeight += weight;
        
        for (const [neighbor, w] of graph[v]) {
            if (!visited.has(neighbor)) {
                edges.push([w, v, neighbor]);
            }
        }
    }
    
    return [mst, totalWeight];
}

// 예시
const graph = {
    0: [[1, 4], [2, 2]],
    1: [[0, 4], [2, 1], [3, 5]],
    2: [[0, 2], [1, 1], [3, 8], [4, 10]],
    3: [[1, 5], [2, 8], [4, 2]],
    4: [[2, 10], [3, 2]]
};
const [mst, total] = prim(graph, 0);
```

---

## 위상 정렬 (Topological Sort)

**시간복잡도**: O(V + E) | **공간복잡도**: O(V)

방향 그래프에서 의존성 관계를 표현합니다.

### DFS 방식

```javascript
function topologicalSortDfs(graph, numNodes) {
    const visited = new Array(numNodes).fill(false);
    const stack = [];
    
    function dfs(node) {
        visited[node] = true;
        for (const neighbor of graph[node] || []) {
            if (!visited[neighbor]) {
                dfs(neighbor);
            }
        }
        stack.push(node);
    }
    
    for (let i = 0; i < numNodes; i++) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    
    return stack.reverse();
}

// 예시
const graph = {0: [1, 2], 1: [3], 2: [3], 3: []};
console.log(topologicalSortDfs(graph, 4));
// [0, 1, 2, 3] 또는 [0, 2, 1, 3]
```

### Kahn 알고리즘 (BFS)

```javascript
function topologicalSortKahn(graph, numNodes) {
    const inDegree = new Array(numNodes).fill(0);
    
    for (let node = 0; node < numNodes; node++) {
        for (const neighbor of graph[node] || []) {
            inDegree[neighbor]++;
        }
    }
    
    const queue = [];
    for (let i = 0; i < numNodes; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }
    
    const result = [];
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph[node] || []) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] === 0) {
                queue.push(neighbor);
            }
        }
    }
    
    return result.length === numNodes ? result : [];
}
```

---

## 강한 연결 요소 (SCC)

**시간복잡도**: O(V + E) | **공간복잡도**: O(V)

Tarjan 알고리즘을 사용합니다.

```javascript
function tarjanSCC(graph, numNodes) {
    const indexCounter = { value: 0 };
    const stack = [];
    const lowlinks = new Array(numNodes).fill(0);
    const index = new Array(numNodes).fill(0);
    const onStack = new Array(numNodes).fill(false);
    const indexInitialized = new Array(numNodes).fill(false);
    const sccs = [];
    
    function strongconnect(node) {
        index[node] = indexCounter.value;
        lowlinks[node] = indexCounter.value;
        indexCounter.value++;
        indexInitialized[node] = true;
        stack.push(node);
        onStack[node] = true;
        
        for (const neighbor of graph[node] || []) {
            if (!indexInitialized[neighbor]) {
                strongconnect(neighbor);
                lowlinks[node] = Math.min(lowlinks[node], lowlinks[neighbor]);
            } else if (onStack[neighbor]) {
                lowlinks[node] = Math.min(lowlinks[node], index[neighbor]);
            }
        }
        
        if (lowlinks[node] === index[node]) {
            const scc = [];
            while (true) {
                const w = stack.pop();
                onStack[w] = false;
                scc.push(w);
                if (w === node) break;
            }
            sccs.push(scc);
        }
    }
    
    for (let node = 0; node < numNodes; node++) {
        if (!indexInitialized[node]) {
            strongconnect(node);
        }
    }
    
    return sccs;
}

// 예시
const graph = {
    0: [1],
    1: [2],
    2: [0, 3],
    3: [4],
    4: [5],
    5: [3]
};
console.log(tarjanSCC(graph, 6));
// [[4, 5, 3], [2, 1, 0]]
```

---

## 그래프 알고리즘 비교표

| 알고리즘 | 시간복잡도 | 공간 | 음수 | 응용 |
|---------|----------|------|-----|------|
| 다익스트라 | O((V+E)logV) | O(V) | X | 최단경로 |
| 벨만-포드 | O(VE) | O(V) | O | 음수간선 |
| 플로이드 | O(V³) | O(V²) | O | 모든쌍 |
| 크루스칼 | O(ElogE) | O(V) | X | MST |
| 프림 | O((V+E)logV) | O(V) | X | MST |
| 위상정렬 | O(V+E) | O(V) | - | 순서 |
| SCC | O(V+E) | O(V) | - | 연결성 |

