# 문자열 알고리즘 완전 가이드

## 목차
1. [KMP 알고리즘](#kmp-알고리즘)
2. [Rabin-Karp 알고리즘](#rabin-karp-알고리즘)
3. [Trie](#trie)
4. [문자열 매칭](#문자열-매칭)

---

## KMP 알고리즘

**시간복잡도**: O(n + m) | **공간복잡도**: O(m)

Knuth-Morris-Pratt 알고리즘은 효율적인 패턴 매칭을 제공합니다.

### LPS (Longest Proper Prefix which is also Suffix) 배열

```javascript
function buildLPS(pattern) {
    /**
     * 패턴에 대한 LPS 배열 구축
     * LPS[i] = pattern[0...i]에서 prefix이면서 suffix인 최대 길이
     */
    const m = pattern.length;
    const lps = new Array(m).fill(0);
    let length = 0;
    let i = 1;
    
    while (i < m) {
        if (pattern[i] === pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length !== 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

// 예시
const pattern = "ABABDABACD";
const lps = buildLPS(pattern);
console.log(lps);  // [0, 0, 1, 2, 0, 1, 2, 3, 0, 0]
```

### KMP 검색

```javascript
function kmpSearch(text, pattern) {
    /**
     * text에서 pattern이 나타나는 모든 위치 반환
     */
    const n = text.length;
    const m = pattern.length;
    
    if (m === 0) {
        return [];
    }
    
    const lps = buildLPS(pattern);
    const results = [];
    let i = 0, j = 0;
    
    while (i < n) {
        if (text[i] === pattern[j]) {
            i++;
            j++;
        }
        
        if (j === m) {
            results.push(i - j);
            j = lps[j - 1];
        } else if (i < n && text[i] !== pattern[j]) {
            if (j !== 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    return results;
}

// 예시
const text = "ABABDABACDABABCABAB";
const pattern = "ABABCABAB";
console.log(kmpSearch(text, pattern));  // [10]
```

---

## Rabin-Karp 알고리즘

**시간복잡도**: O(n + m) 평균 | **공간복잡도**: O(1)

해시를 이용한 패턴 매칭입니다.

```javascript
function rabinKarp(text, pattern) {
    /**
     * Rolling hash를 이용한 패턴 매칭
     */
    const n = text.length;
    const m = pattern.length;
    const prime = 101;
    const base = 256;
    
    if (m > n) {
        return [];
    }
    
    let patternHash = 0;
    let textHash = 0;
    let basePower = 1;
    
    // 패턴과 텍스트의 첫 윈도우 해시 계산
    for (let i = 0; i < m; i++) {
        patternHash = (patternHash * base + text.charCodeAt(pattern[i])) % prime;
        textHash = (textHash * base + text.charCodeAt(text[i])) % prime;
        if (i < m - 1) {
            basePower = (basePower * base) % prime;
        }
    }
    
    const results = [];
    
    // 텍스트 윈도우 슬라이드
    for (let i = 0; i <= n - m; i++) {
        if (patternHash === textHash) {
            // 해시 충돌 확인 - 실제 패턴 비교
            if (text.substring(i, i + m) === pattern) {
                results.push(i);
            }
        }
        
        // 다음 윈도우 해시 계산 (rolling hash)
        if (i < n - m) {
            textHash = (base * (textHash - text.charCodeAt(i) * basePower) + text.charCodeAt(i + m)) % prime;
            if (textHash < 0) {
                textHash += prime;
            }
        }
    }
    
    return results;
}

// 예시
const text = "ABCCDDEFFGGH";
const pattern = "CDDEFFG";
console.log(rabinKarp(text, pattern));  // [2]
```

---

## Trie

**시간복잡도**: 삽입/검색/삭제 O(m) (m은 문자열 길이) | **공간복잡도**: O(alphabet_size × n)

접두사 트리는 문자열 저장과 빠른 검색에 최적입니다.

### 기본 구현

```javascript
class TrieNode {
    constructor() {
        this.children = {};
        this.isEnd = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        /**문자열 삽입*/
        let node = this.root;
        for (const char of word) {
            if (!node.children[char]) {
                node.children[char] = new TrieNode();
            }
            node = node.children[char];
        }
        node.isEnd = true;
    }
    
    search(word) {
        /**정확한 단어 검색*/
        let node = this.root;
        for (const char of word) {
            if (!node.children[char]) {
                return false;
            }
            node = node.children[char];
        }
        return node.isEnd;
    }
    
    startsWith(prefix) {
        /**접두사 검색*/
        let node = this.root;
        for (const char of prefix) {
            if (!node.children[char]) {
                return false;
            }
            node = node.children[char];
        }
        return true;
    }
    
    getWordsWithPrefix(prefix) {
        /**주어진 접두사로 시작하는 모든 단어 반환*/
        let node = this.root;
        for (const char of prefix) {
            if (!node.children[char]) {
                return [];
            }
            node = node.children[char];
        }
        
        const words = [];
        this._dfs(node, prefix, words);
        return words;
    }
    
    _dfs(node, current, words) {
        if (node.isEnd) {
            words.push(current);
        }
        for (const [char, childNode] of Object.entries(node.children)) {
            this._dfs(childNode, current + char, words);
        }
    }
}

// 예시
const trie = new Trie();
trie.insert("apple");
trie.insert("app");
trie.insert("application");

console.log(trie.search("apple"));          // true
console.log(trie.search("app"));            // true
console.log(trie.search("appl"));           // false
console.log(trie.startsWith("app"));        // true
console.log(trie.getWordsWithPrefix("app")); // ['apple', 'app', 'application']
```

### 자동 완성 (Top K)

```javascript
class AutoComplete {
    constructor() {
        this.root = new TrieNode();
    }
    
    insertWithCount(word) {
        let node = this.root;
        for (const char of word) {
            if (!node.children[char]) {
                node.children[char] = new TrieNode();
            }
            node = node.children[char];
            node.count = (node.count || 0) + 1;
        }
        node.isEnd = true;
    }
    
    getTopKWithPrefix(prefix, k = 5) {
        /**접두사로 시작하는 상위 k개 단어*/
        let node = this.root;
        for (const char of prefix) {
            if (!node.children[char]) {
                return [];
            }
            node = node.children[char];
        }
        
        const candidates = [];
        this._dfsWithCount(node, prefix, candidates);
        
        // count 기준으로 정렬 (내림차순)
        candidates.sort((a, b) => b[1] - a[1]);
        return candidates.slice(0, k).map(item => item[0]);
    }
    
    _dfsWithCount(node, current, candidates) {
        if (node.isEnd) {
            candidates.push([current, node.count || 1]);
        }
        for (const [char, childNode] of Object.entries(node.children)) {
            this._dfsWithCount(childNode, current + char, candidates);
        }
    }
}
```

---

## 문자열 매칭 비교

| 알고리즘 | 시간복잡도 | 공간 | 특징 |
|---------|----------|------|------|
| 소박함 | O(nm) | O(1) | 간단함 |
| KMP | O(n+m) | O(m) | 최적 |
| Rabin-Karp | O(n+m) | O(1) | 해시 충돌 |
| Boyer-Moore | O(n/m) | O(m) | 실제로 빠름 |
| Aho-Corasick | O(n+m+k) | O(m*σ) | 다중 패턴 |

---

## 자주 나오는 문자열 문제

1. **패턴 매칭**: KMP, Rabin-Karp
2. **자동 완성**: Trie + Top K
3. **단어 검색**: Trie
4. **최장 공통 부분수열**: DP
5. **편집 거리**: DP
6. **회문 검사**: 2포인터 또는 해시
7. **아나그램**: 정렬 또는 해시
8. **부분 문자열**: KMP 또는 해시

