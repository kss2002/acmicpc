# 정렬 알고리즘 완전 가이드

## 목차
1. [버블 정렬](#버블-정렬-bubble-sort)
2. [선택 정렬](#선택-정렬-selection-sort)
3. [삽입 정렬](#삽입-정렬-insertion-sort)
4. [병합 정렬](#병합-정렬-merge-sort)
5. [퀵 정렬](#퀵-정렬-quick-sort)
6. [힙 정렬](#힙-정렬-heap-sort)
7. [계수 정렬](#계수-정렬-counting-sort)

---

## 버블 정렬 (Bubble Sort)

**시간복잡도**: O(n²) | **공간복잡도**: O(1)

인접한 두 원소를 비교하여 순서가 맞지 않으면 교환하는 알고리즘입니다. 가장 간단하지만 비효율적입니다.

### 기본 개념
- 매 반복마다 가장 큰 원소가 배열의 끝으로 이동
- 안정 정렬(Stable Sort)
- In-place 정렬

### 코드

```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        // 이미 정렬된 부분을 건너뛰기
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

// 최적화 버전: 교환이 없으면 이미 정렬됨
function bubbleSortOptimized(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        let swapped = false;
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true;
            }
        }
        if (!swapped) break;
    }
    return arr;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSortOptimized(arr));  // [11, 12, 22, 25, 34, 64, 90]
```

### 동작 예시
```
[64, 34, 25, 12, 22, 11, 90]
[34, 25, 12, 22, 11, 64, 90]  // 64가 이동
[25, 12, 22, 11, 34, 64, 90]  // 34가 이동
...
```

### 장점
- 구현이 매우 간단
- 추가 메모리가 거의 필요 없음
- 안정 정렬

### 단점
- O(n²) 시간복잡도로 느림
- 대규모 데이터에 부적합

---

## 선택 정렬 (Selection Sort)

**시간복잡도**: O(n²) | **공간복잡도**: O(1)

최솟값을 찾아 맨 앞으로 옮기는 방식입니다.

### 기본 개념
- 매 반복마다 최솟값을 찾아 현재 위치로 이동
- In-place 정렬
- 불안정 정렬(Unstable Sort)

### 코드

```javascript
function selectionSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        let minIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
    }
    return arr;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(selectionSort(arr));  // [11, 12, 22, 25, 34, 64, 90]
```

### 동작 예시
```
[64, 34, 25, 12, 22, 11, 90]
[11, 34, 25, 12, 22, 64, 90]  // 11을 맨 앞으로
[11, 12, 25, 34, 22, 64, 90]  // 12를 두 번째로
...
```

### 특징
- 비교 횟수는 n(n-1)/2로 항상 일정
- 교환 횟수가 최소 (n-1회)
- 메모리 사용이 적음

---

## 삽입 정렬 (Insertion Sort)

**시간복잡도**: O(n²) 평균, O(n) 최선 | **공간복잡도**: O(1)

이미 정렬된 부분에 새로운 원소를 삽입합니다. 작은 배열이나 거의 정렬된 배열에서 효과적입니다.

### 기본 개념
- 두 번째 원소부터 시작
- 정렬된 부분과 정렬되지 않은 부분으로 나눔
- 안정 정렬
- In-place 정렬

### 코드

```javascript
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        const key = arr[i];
        let j = i - 1;
        // key보다 큰 원소들을 오른쪽으로 이동
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(insertionSort(arr));  // [11, 12, 22, 25, 34, 64, 90]
```

### 동작 예시
```
[64, 34, 25, 12, 22, 11, 90]
[34, 64, 25, 12, 22, 11, 90]  // 34를 삽입
[25, 34, 64, 12, 22, 11, 90]  // 25를 삽입
...
```

### 특징
- 거의 정렬된 배열에서 O(n)에 가까운 성능
- 온라인 정렬(순차 데이터 처리 가능)
- 매우 작은 배열에서는 퀵 정렬보다 빠를 수 있음

---

## 병합 정렬 (Merge Sort)

**시간복잡도**: O(n log n) | **공간복잡도**: O(n)

분할 정복 방식으로 배열을 반으로 나누어 정렬한 후 병합합니다. 안정 정렬이며 항상 O(n log n)을 보장합니다.

### 기본 개념
- 배열을 절반으로 계속 분할
- 원소가 1개일 때까지 분할
- 병합하면서 정렬
- 안정 정렬

### 코드

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    // 배열 분할
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    // 병합
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    // 두 배열을 비교하며 작은 것부터 추가
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    // 남은 원소들 추가
    result.push(...left.slice(i));
    result.push(...right.slice(j));
    return result;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(mergeSort(arr));  // [11, 12, 22, 25, 34, 64, 90]
```

### 병합 과정 시각화
```
[64, 34, 25, 12, 22, 11, 90]
     ↓
[64, 34, 25] [12, 22, 11, 90]
    ↓            ↓
[64, 34] [25] [12, 22] [11, 90]
  ↓        ↓      ↓       ↓
[64][34] [25] [12][22] [11][90]
  ↓        ↓      ↓       ↓
[34,64] [25] [12,22] [11,90]
  ↓        ↓      ↓       ↓
[25,34,64] [11,12,22,90]
        ↓
[11,12,22,25,34,64,90]
```

### 특징
- 항상 O(n log n) 보장
- 외부 정렬(파일 정렬)에 최적
- 안정 정렬
- 추가 메모리 필요

---

## 퀵 정렬 (Quick Sort)

**시간복잡도**: O(n log n) 평균, O(n²) 최악 | **공간복잡도**: O(log n) 재귀

피벗을 기준으로 분할하여 정렬합니다. 실제로 가장 빠른 경우가 많습니다.

### 기본 개념
- 피벗을 선택하여 분할
- 피벗보다 작은 것은 왼쪽, 큰 것은 오른쪽
- In-place 정렬
- 불안정 정렬

### 코드

```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pivotIdx = partition(arr, low, high);
        quickSort(arr, low, pivotIdx - 1);
        quickSort(arr, pivotIdx + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// 간단한 버전
function quickSortSimple(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSortSimple(left), ...middle, ...quickSortSimple(right)];
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort([...arr]));  // [11, 12, 22, 25, 34, 64, 90]
```

### 분할 과정
```
[64, 34, 25, 12, 22, 11, 90] (pivot=25)
[11, 12, 22] [25] [64, 34, 90]
```

### 피벗 선택 전략
- **랜덤 피벗**: 최악의 경우 피하기
- **중간값 피벗**: 균형잡힌 분할
- **3개 중 중간값**: 더 좋은 성능

### 특징
- 평균적으로 O(n log n)
- 캐시 친화적 (데이터 지역성)
- 실제로는 병합 정렬보다 빠른 경우가 많음

---

## 힙 정렬 (Heap Sort)

**시간복잡도**: O(n log n) | **공간복잡도**: O(1)

최대 힙을 구성하여 정렬합니다.

### 기본 개념
- 힙 자료구조 이용
- 최대 힙 구성 후 루트를 제거
- In-place 정렬
- 불안정 정렬

### 코드

```javascript
function heapSort(arr) {
    const n = arr.length;
    
    // 최대 힙 구성
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 하나씩 꺼내기
    for (let i = n - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(arr, i, 0);
    }
    
    return arr;
}

function heapify(arr, n, i) {
    let largest = i;
    const left = 2 * i + 1;
    const right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest !== i) {
        [arr[i], arr[largest]] = [arr[largest], arr[i]];
        heapify(arr, n, largest);
    }
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(heapSort([...arr]));  // [11, 12, 22, 25, 34, 64, 90]
```

### 힙 구조 (배열 기반)
```
        64
       /  \
      34   25
     / \   / \
    12  22 11  90

배열: [64, 34, 25, 12, 22, 11, 90]
부모(i): Math.floor((i-1)/2)
왼쪽 자식(i): 2*i+1
오른쪽 자식(i): 2*i+2
```

### 특징
- 항상 O(n log n) 보장
- 최악의 경우에도 좋은 성능
- 거의 정렬된 배열에도 효율적
- 캐시 효율이 낮음 (점프가 많음)

---

## 계수 정렬 (Counting Sort)

**시간복잡도**: O(n + k) (k는 최댓값) | **공간복잡도**: O(k)

정수의 개수를 세어 정렬합니다. 음수가 없고 범위가 작을 때 매우 빠릅니다.

### 기본 개념
- 각 원소의 개수를 센다
- 누적 합을 계산
- 뒤에서부터 원소를 배치
- 안정 정렬

### 코드

```javascript
function countingSort(arr, maxVal) {
    // 카운팅 배열 생성
    const count = new Array(maxVal + 1).fill(0);
    
    for (const num of arr) {
        count[num]++;
    }
    
    // 누적 합
    for (let i = 1; i <= maxVal; i++) {
        count[i] += count[i - 1];
    }
    
    // 결과 배열 생성
    const result = new Array(arr.length);
    for (let i = arr.length - 1; i >= 0; i--) {
        const num = arr[i];
        const idx = count[num] - 1;
        result[idx] = num;
        count[num]--;
    }
    
    return result;
}

// 음수를 포함한 버전
function countingSortWithNegative(arr) {
    if (arr.length === 0) return arr;
    
    const minVal = Math.min(...arr);
    const maxVal = Math.max(...arr);
    const rangeSize = maxVal - minVal + 1;
    
    const count = new Array(rangeSize).fill(0);
    
    for (const num of arr) {
        count[num - minVal]++;
    }
    
    const result = [];
    for (let i = 0; i < rangeSize; i++) {
        for (let j = 0; j < count[i]; j++) {
            result.push(i + minVal);
        }
    }
    
    return result;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(countingSort(arr, 90));  // [11, 12, 22, 25, 34, 64, 90]
```

### 동작 예시
```
arr = [64, 34, 25, 12, 22, 11, 90]
maxVal = 90

count = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, ..., 1, 0, ..., 1, 1, 0, 1]
(인덱스 11에 1, 12에 1, ... 64에 1, 90에 1)

누적합 후:
count = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, ..., 6, 6, ..., 7, 8, 8, 9]
```

### 조건
- 정수 정렬만 가능
- 범위가 작아야 함
- 음수가 없거나 처리 필요

### 특징
- 범위가 작으면 가장 빠름
- 안정 정렬
- 메모리 트레이드오프

---

## 정렬 알고리즘 비교표

| 알고리즘 | 평균 시간 | 최악 시간 | 공간 | 안정성 | In-place | 용도 |
|---------|---------|---------|------|--------|---------|------|
| 버블 | O(n²) | O(n²) | O(1) | O | O | 교육용 |
| 선택 | O(n²) | O(n²) | O(1) | X | O | 메모리 제약 |
| 삽입 | O(n²) | O(n²) | O(1) | O | O | 작은 배열 |
| 병합 | O(n log n) | O(n log n) | O(n) | O | X | 안정성 필요 |
| 퀵 | O(n log n) | O(n²) | O(log n) | X | O | 일반 목적 |
| 힙 | O(n log n) | O(n log n) | O(1) | X | O | 최악 성능 |
| 계수 | O(n+k) | O(n+k) | O(k) | O | X | 정수 범위 작음 |

---

## 실전 선택 팁

1. **일반적인 경우**: 퀵 정렬 또는 병합 정렬
2. **안정 정렬 필요**: 병합 정렬
3. **메모리 제약**: 힙 정렬
4. **작은 배열**: 삽입 정렬
5. **정수 범위 작음**: 계수 정렬
6. **거의 정렬됨**: 삽입 정렬
7. **최악의 경우 피하기**: 병합 정렬이나 힙 정렬

