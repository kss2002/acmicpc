# 동적 프로그래밍 완전 가이드

## 목차
1. [기본 개념](#기본-개념)
2. [피보나치 수열](#피보나치-수열)
3. [배낭 문제](#배낭-문제)
4. [동전 교환](#동전-교환)
5. [최장 증가 부분수열](#최장-증가-부분수열-lis)
6. [최장 공통 부분수열](#최장-공통-부분수열-lcs)
7. [편집 거리](#편집-거리)
8. [계단 오르기](#계단-오르기)
9. [최대 부분 배열 합](#최대-부분-배열-합)

---

## 기본 개념

동적 프로그래밍은 다음 두 가지 조건을 만족하는 문제를 푸는 기법입니다:

1. **최적 부분 구조 (Optimal Substructure)**: 큰 문제의 최적해가 작은 부분 문제의 최적해로 구성
2. **중복되는 부분 문제 (Overlapping Subproblems)**: 같은 부분 문제가 반복됨

### 두 가지 접근법

**하향식 (Top-Down) - Memoization**
- 재귀 함수에서 시작
- 계산 결과를 캐싱
- 필요한 부분만 계산

**상향식 (Bottom-Up) - Tabulation**
- 작은 문제부터 시작
- 배열에 결과 저장
- 모든 부분 계산

---

## 피보나치 수열

### 재귀 (매우 비효율적)

```javascript
// 시간복잡도: O(2^n) - 매우 느림
function fibRecursive(n) {
    if (n <= 1) {
        return n;
    }
    return fibRecursive(n - 1) + fibRecursive(n - 2);
}
```

### Memoization (하향식 DP)

```javascript
// 시간복잡도: O(n), 공간복잡도: O(n)
function fibMemo(n, memo = {}) {
    if (n in memo) {
        return memo[n];
    }
    if (n <= 1) {
        return n;
    }
    
    memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    return memo[n];
}

// 예시
console.log(fibMemo(50));  // 12586269025 (빠르게 계산됨)
```

### Tabulation (상향식 DP)

```javascript
// 시간복잡도: O(n), 공간복잡도: O(n)
function fibDP(n) {
    if (n <= 1) {
        return n;
    }
    
    const dp = new Array(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// 예시
console.log(fibDP(50));  // 12586269025
```

### 공간 최적화

```javascript
// 시간복잡도: O(n), 공간복잡도: O(1)
function fibOptimized(n) {
    if (n <= 1) {
        return n;
    }
    
    let prev = 0, curr = 1;
    for (let i = 2; i <= n; i++) {
        [prev, curr] = [curr, prev + curr];
    }
    
    return curr;
}

// 예시
console.log(fibOptimized(50));  // 12586269025
```

---

## 배낭 문제

### 0/1 배낭 (각 물건을 한 번만)

**시간복잡도**: O(nW) | **공간복잡도**: O(nW)

```javascript
function knapsack01(weights, values, capacity) {
    const n = weights.length;
    // dp[i][w] = i번째 물건까지 고려했을 때, 용량 w일 때의 최대 가치
    const dp = Array(n + 1).fill(0).map(() => Array(capacity + 1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= capacity; w++) {
            // 현재 물건을 넣지 않는 경우
            dp[i][w] = dp[i - 1][w];
            
            // 현재 물건을 넣을 수 있으면 넣는 경우와 비교
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(
                    dp[i][w],
                    dp[i - 1][w - weights[i - 1]] + values[i - 1]
                );
            }
        }
    }
    
    return dp[n][capacity];
}

// 예시
const weights = [2, 3, 4, 5];
const values = [3, 4, 5, 6];
const capacity = 5;
console.log(knapsack01(weights, values, capacity));  // 10
```

### 공간 최적화

```javascript
function knapsack01Optimized(weights, values, capacity) {
    const dp = new Array(capacity + 1).fill(0);
    
    for (let i = 0; i < weights.length; i++) {
        // 역순으로 순회해야 같은 물건을 중복 사용하지 않음
        for (let w = capacity; w >= weights[i]; w--) {
            dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}
```

---

## 동전 교환

### 최소 동전 개수

**시간복잡도**: O(n × amount) | **공간복잡도**: O(amount)

```javascript
function coinChange(coins, amount) {
    // dp[i] = 금액 i를 만드는 최소 동전 개수
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;
    
    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    
    return dp[amount] === Infinity ? -1 : dp[amount];
}

// 예시
const coins = [1, 2, 5];
const amount = 5;
console.log(coinChange(coins, amount));  // 1 (5원짜리 동전 1개)
```

### 경우의 수

```javascript
function coinChangeCombo(coins, amount) {
    const dp = new Array(amount + 1).fill(0);
    dp[0] = 1;
    
    for (const coin of coins) {
        for (let i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    
    return dp[amount];
}

// 예시
const coins = [1, 2, 5];
const amount = 5;
console.log(coinChangeCombo(coins, amount));  // 4
```

---

## 최장 증가 부분수열 (LIS)

### O(n²) 버전

```javascript
function lisSlowO(arr) {
    const n = arr.length;
    const dp = new Array(n).fill(1);
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max(...dp);
}

// 예시
const arr = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(lisSlowO(arr));  // 4
```

### O(n log n) 이진 탐색 버전

```javascript
function lisFastO(arr) {
    const tails = [];
    
    for (const num of arr) {
        let left = 0, right = tails.length;
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left === tails.length) {
            tails.push(num);
        } else {
            tails[left] = num;
        }
    }
    
    return tails.length;
}

// 예시
const arr = [10, 9, 2, 5, 3, 7, 101, 18];
console.log(lisFastO(arr));  // 4
```

---

## 최장 공통 부분수열 (LCS)

**시간복잡도**: O(m × n) | **공간복잡도**: O(m × n)

```javascript
function lcs(text1, text2) {
    const m = text1.length;
    const n = text2.length;
    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// 예시
const text1 = "abcde";
const text2 = "ace";
console.log(lcs(text1, text2));  // 3
```

### 실제 부분수열 반환

```javascript
function lcsWithString(text1, text2) {
    const m = text1.length;
    const n = text2.length;
    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // 역추적
    const result = [];
    let i = m, j = n;
    while (i > 0 && j > 0) {
        if (text1[i - 1] === text2[j - 1]) {
            result.unshift(text1[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return result.join('');
}

// 예시
const text1 = "abcde";
const text2 = "ace";
console.log(lcsWithString(text1, text2));  // "ace"
```

---

## 편집 거리

**시간복잡도**: O(m × n) | **공간복잡도**: O(m × n)

```javascript
function editDistance(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
    
    // 초기화
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i - 1][j],      // 삭제
                    dp[i][j - 1],      // 삽입
                    dp[i - 1][j - 1]   // 교체
                );
            }
        }
    }
    
    return dp[m][n];
}

// 예시
const word1 = "horse";
const word2 = "ros";
console.log(editDistance(word1, word2));  // 3
```

---

## 계단 오르기

```javascript
function climbStairs(n) {
    if (n <= 2) {
        return n;
    }
    
    let prev = 1, curr = 2;
    for (let i = 3; i <= n; i++) {
        [prev, curr] = [curr, prev + curr];
    }
    
    return curr;
}

// 예시
console.log(climbStairs(5));  // 8
```

---

## 최대 부분 배열 합

**Kadane의 알고리즘**

```javascript
function maxSubarraySum(arr) {
    let maxSum = arr[0];
    let currentSum = arr[0];
    
    for (let i = 1; i < arr.length; i++) {
        currentSum = Math.max(arr[i], currentSum + arr[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}

// 예시
const arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(maxSubarraySum(arr));  // 6
```

### 부분 배열 추적

```javascript
function maxSubarraySumWithIndices(arr) {
    let maxSum = arr[0];
    let currentSum = arr[0];
    let maxStart = 0, maxEnd = 0, currentStart = 0;
    
    for (let i = 1; i < arr.length; i++) {
        if (currentSum < 0) {
            currentSum = arr[i];
            currentStart = i;
        } else {
            currentSum += arr[i];
        }
        
        if (currentSum > maxSum) {
            maxSum = currentSum;
            maxStart = currentStart;
            maxEnd = i;
        }
    }
    
    return [maxSum, maxStart, maxEnd, arr.slice(maxStart, maxEnd + 1)];
}

// 예시
const arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
const [sum, start, end, subarray] = maxSubarraySumWithIndices(arr);
console.log(`최대 합: ${sum}, 범위: [${start}, ${end}], 부분배열: ${subarray}`);
```

---

## DP 문제 해결 단계

1. **문제 이해**: 상태를 정의
2. **점화식 도출**: 이전 상태와의 관계식
3. **기저 사례**: 초기값 설정
4. **구현**: Memoization 또는 Tabulation
5. **최적화**: 공간/시간 개선

