# 탐색 알고리즘 완전 가이드

## 목차
1. [선형 탐색](#선형-탐색-linear-search)
2. [이진 탐색](#이진-탐색-binary-search)
3. [깊이 우선 탐색](#깊이-우선-탐색-dfs)
4. [너비 우선 탐색](#너비-우선-탐색-bfs)

---

## 선형 탐색 (Linear Search)

**시간복잡도**: O(n) | **공간복잡도**: O(1)

가장 간단한 탐색 방법입니다. 배열의 처음부터 끝까지 순차적으로 탐색합니다.

### 기본 개념
- 정렬되지 않은 배열에서도 사용 가능
- 작은 배열에서 효과적
- 순차 접근이 빠른 데이터에 유용

### 코드

```javascript
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }
    }
    return -1;
}

// 모든 발생 위치 반환
function linearSearchAll(arr, target) {
    const results = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            results.push(i);
        }
    }
    return results;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(linearSearch(arr, 25));  // 2
console.log(linearSearchAll(arr, 25));  // [2]
```

### 언제 사용할까?
- 정렬되지 않은 배열
- 작은 배열 (n < 100)
- 한 번만 탐색할 때

---

## 이진 탐색 (Binary Search)

**시간복잡도**: O(log n) | **공간복잡도**: O(1) 반복, O(log n) 재귀

정렬된 배열에서 매우 빠른 탐색이 가능합니다. 탐색 범위를 반으로 줄여나갑니다.

### 기본 개념
- **정렬된 배열 필수**
- 중간값과 비교하여 범위 축소
- 반복 또는 재귀 구현 가능

### 반복 방식

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

// 예시
const arr = [11, 12, 22, 25, 34, 64, 90];
console.log(binarySearch(arr, 25));  // 3
console.log(binarySearch(arr, 100));  // -1
```

### 재귀 방식

```javascript
function binarySearchRecursive(arr, target, left, right) {
    if (left > right) {
        return -1;
    }
    
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

// 사용
const arr = [11, 12, 22, 25, 34, 64, 90];
console.log(binarySearchRecursive(arr, 25, 0, arr.length - 1));  // 3
```

### 첫 번째 발생 위치 찾기

```javascript
function binarySearchFirst(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            result = mid;
            right = mid - 1;  // 왼쪽으로 더 탐색
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

// 예시
const arr = [11, 12, 12, 12, 25, 34, 64, 90];
console.log(binarySearchFirst(arr, 12));  // 1
```

### 마지막 발생 위치 찾기

```javascript
function binarySearchLast(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            result = mid;
            left = mid + 1;  // 오른쪽으로 더 탐색
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

// 예시
const arr = [11, 12, 12, 12, 25, 34, 64, 90];
console.log(binarySearchLast(arr, 12));  // 3
```

### 범위 탐색

```javascript
function binarySearchRange(arr, target) {
    const first = binarySearchFirst(arr, target);
    if (first === -1) {
        return [-1, -1];
    }
    const last = binarySearchLast(arr, target);
    return [first, last];
}

// 예시
const arr = [11, 12, 12, 12, 25, 34, 64, 90];
console.log(binarySearchRange(arr, 12));  // [1, 3]
```

### 탐색 과정 시각화

```
arr = [11, 12, 22, 25, 34, 64, 90]
target = 25

Step 1: left=0, right=6, mid=3
        arr[3]=25, target=25 → 찾음! 반환 3

Step 1: left=0, right=6, mid=3
        arr[3]=25 > 22, right=2
Step 2: left=0, right=2, mid=1
        arr[1]=12 < 22, left=2
Step 3: left=2, right=2, mid=2
        arr[2]=22 < 25, left=3
Step 4: left=3, right=2 → 찾지 못함, 반환 -1
```

### 특징
- 정렬된 배열 필수
- 매우 빠른 성능
- 큰 배열에서 강력함

---

## 깊이 우선 탐색 (DFS)

**시간복잡도**: O(V + E) | **공간복잡도**: O(V)

스택이나 재귀를 이용하여 그래프를 깊게 탐색합니다.

### 기본 개념
- 한 경로를 완전히 탐색한 후 다른 경로 탐색
- 스택 또는 재귀 사용
- 방문 여부 추적 필수

### 재귀 방식

```javascript
function dfsRecursive(graph, node, visited = new Set()) {
    visited.add(node);
    console.log(node);
    
    for (const neighbor of graph[node]) {
        if (!visited.has(neighbor)) {
            dfsRecursive(graph, neighbor, visited);
        }
    }
    
    return visited;
}

// 예시
const graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1],
    4: [2]
};
dfsRecursive(graph, 0);  // 0 1 3 2 4
```

### 반복 방식 (스택 사용)

```javascript
function dfsIterative(graph, start) {
    const visited = new Set();
    const stack = [start];
    const result = [];
    
    while (stack.length > 0) {
        const node = stack.pop();
        if (!visited.has(node)) {
            visited.add(node);
            result.push(node);
            // 역순으로 추가해야 올바른 순서
            stack.push(...graph[node].reverse());
        }
    }
    
    return result;
}

// 예시
const graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1],
    4: [2]
};
console.log(dfsIterative(graph, 0));  // [0, 1, 3, 2, 4]
```

### 경로 추적

```javascript
function dfsWithPath(graph, start, end) {
    const visited = new Set();
    const path = [];
    
    function dfs(node) {
        visited.add(node);
        path.push(node);
        
        if (node === end) {
            return true;
        }
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                if (dfs(neighbor)) {
                    return true;
                }
            }
        }
        
        path.pop();
        return false;
    }
    
    if (dfs(start)) {
        return path;
    }
    return null;
}

// 예시
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B'],
    'E': ['C']
};
console.log(dfsWithPath(graph, 'A', 'E'));  // ['A', 'C', 'E']
```

### 응용
- 연결 요소 찾기
- 위상 정렬
- 사이클 감지
- 미로 풀이

---

## 너비 우선 탐색 (BFS)

**시간복잡도**: O(V + E) | **공간복잡도**: O(V)

큐를 이용하여 같은 깊이의 노드를 먼저 탐색합니다. 최단 경로 찾기에 최적입니다.

### 기본 개념
- 큐 사용 (FIFO)
- 레벨별로 탐색
- 최단 경로 보장

### 기본 구현

```javascript
function bfs(graph, start) {
    const visited = new Set([start]);
    const queue = [start];
    const result = [];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return result;
}

// 예시
const graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1],
    4: [2]
};
console.log(bfs(graph, 0));  // [0, 1, 2, 3, 4]
```

### 최단 경로 찾기

```javascript
function bfsShortestPath(graph, start, end) {
    const visited = new Set([start]);
    const queue = [[start, [start]]];
    
    while (queue.length > 0) {
        const [node, path] = queue.shift();
        
        if (node === end) {
            return path;
        }
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, [...path, neighbor]]);
            }
        }
    }
    
    return null;
}

// 예시
const graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B'],
    'E': ['C']
};
console.log(bfsShortestPath(graph, 'A', 'E'));  // ['A', 'C', 'E']
```

### 레벨별 처리

```javascript
function bfsByLevel(graph, start) {
    const visited = new Set([start]);
    const queue = [start];
    let level = 0;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        console.log(`Level ${level}:`, queue.slice(0, levelSize).join(' '));
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            for (const neighbor of graph[node]) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        level++;
    }
}

// 예시
const graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1],
    4: [2]
};
bfsByLevel(graph, 0);
// Level 0: 0
// Level 1: 1 2
// Level 2: 3 4
```

### 최단 거리 계산

```javascript
function bfsShortestDistance(graph, start) {
    const distances = {};
    for (const node in graph) {
        distances[node] = Infinity;
    }
    distances[start] = 0;
    
    const queue = [start];
    const visited = new Set([start]);
    
    while (queue.length > 0) {
        const node = queue.shift();
        
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                distances[neighbor] = distances[node] + 1;
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return distances;
}

// 예시
const graph = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 4],
    3: [1],
    4: [2]
};
console.log(bfsShortestDistance(graph, 0));
// {0: 0, 1: 1, 2: 1, 3: 2, 4: 2}
```

### 응용
- 최단 경로 찾기
- 거리 계산
- 모든 인접 노드 찾기
- 레벨별 순회

---

## DFS vs BFS 비교

| 특성 | DFS | BFS |
|------|-----|-----|
| 자료구조 | 스택/재귀 | 큐 |
| 메모리 | 높음 (깊은 경우) | 높음 (넓은 경우) |
| 최단 경로 | 보장 안 함 | 보장 함 |
| 속도 | 대체로 빠름 | 대체로 느림 |
| 응용 | 위상정렬, 사이클 | 최단경로 |

---

## 실전 선택 팁

1. **일반 탐색**: 선형 탐색
2. **정렬된 배열**: 이진 탐색
3. **그래프 깊게**: DFS
4. **최단 경로**: BFS
5. **메모리 제약**: DFS
6. **시간 제약**: BFS

