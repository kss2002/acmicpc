# 분할 정복 완전 가이드

## 목차
1. [기본 개념](#기본-개념)
2. [병합 정렬](#병합-정렬)
3. [퀵 정렬](#�익-정렬)
4. [이진 탐색](#이진-탐색)
5. [최대값과 최솟값](#최대값과-최솟값)
6. [거듭제곱 계산](#거듭제곱-계산)
7. [행렬 곱셈](#행렬-곱셈)

---

## 기본 개념

**분할 정복(Divide and Conquer)**은 큰 문제를 작은 부분 문제로 나누어 푼 후 결과를 합치는 알고리즘 설계 기법입니다.

### 세 가지 단계

1. **분할(Divide)**: 문제를 더 작은 부분 문제로 분할
2. **정복(Conquer)**: 부분 문제를 재귀적으로 해결
3. **결합(Combine)**: 부분 해를 합쳐 원래 문제 해결

### 마스터 정리 (Master Theorem)

```
T(n) = aT(n/b) + f(n)

1. f(n) = O(n^(log_b(a) - ε)) 이면 T(n) = O(n^(log_b(a)))
2. f(n) = Θ(n^(log_b(a))) 이면 T(n) = O(n^(log_b(a)) * log n)
3. f(n) = Ω(n^(log_b(a) + ε)) 이고 af(n/b) ≤ cf(n) 이면 T(n) = O(f(n))
```

### 예시 분석

```
병합 정렬: T(n) = 2T(n/2) + O(n)
- a=2, b=2, f(n)=O(n)
- log_2(2) = 1
- f(n) = Θ(n^1) → Case 2 → T(n) = O(n log n)
```

---

## 병합 정렬

**시간복잡도**: O(n log n) | **공간복잡도**: O(n)

배열을 반으로 계속 분할하여 정렬한 후 병합합니다.

### 구현

```javascript
function mergeSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    // 분할
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    // 결합
    return merge(left, right);
}

function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    
    // 두 배열을 비교하며 작은 것부터 추가
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    // 남은 원소들 추가
    result.push(...left.slice(i));
    result.push(...right.slice(j));
    return result;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(mergeSort(arr));  // [11, 12, 22, 25, 34, 64, 90]
```

### In-place 병합 정렬

```javascript
function mergeSortInPlace(arr, left = 0, right = arr.length - 1) {
    if (left < right) {
        const mid = Math.floor((left + right) / 2);
        mergeSortInPlace(arr, left, mid);
        mergeSortInPlace(arr, mid + 1, right);
        mergeInPlace(arr, left, mid, right);
    }
    return arr;
}

function mergeInPlace(arr, left, mid, right) {
    const leftArr = arr.slice(left, mid + 1);
    const rightArr = arr.slice(mid + 1, right + 1);
    
    let i = 0, j = 0, k = left;
    
    while (i < leftArr.length && j < rightArr.length) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    while (i < leftArr.length) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    
    while (j < rightArr.length) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}
```

---

## 퀵 정렬

**시간복잡도**: O(n log n) 평균, O(n²) 최악 | **공간복잡도**: O(log n)

피벗을 기준으로 분할하여 정렬합니다.

### 구현

```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pivotIdx = partition(arr, low, high);
        quickSort(arr, low, pivotIdx - 1);
        quickSort(arr, pivotIdx + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort([...arr]));  // [11, 12, 22, 25, 34, 64, 90]
```

### 간단한 버전

```javascript
function quickSortSimple(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSortSimple(left), ...middle, ...quickSortSimple(right)];
}
```

---

## 이진 탐색

**시간복잡도**: O(log n) | **공간복잡도**: O(1) 반복, O(log n) 재귀

정렬된 배열에서 분할 정복으로 탐색합니다.

### 재귀 방식

```javascript
function binarySearchRecursive(arr, target, left, right) {
    if (left > right) {
        return -1;
    }
    
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

// 예시
const arr = [11, 12, 22, 25, 34, 64, 90];
console.log(binarySearchRecursive(arr, 25, 0, arr.length - 1));  // 3
```

---

## 최대값과 최솟값

**시간복잡도**: O(n) | **공간복잡도**: O(log n)

분할 정복으로 n-1번의 비교로 최대/최소 동시에 찾기:

```javascript
function findMinMax(arr, low, high) {
    /**
     * [최솟값, 최댓값] 반환
     * 비교 횟수: 약 1.5n
     */
    if (low === high) {
        return [arr[low], arr[high]];
    }
    
    if (high - low === 1) {
        return [Math.min(arr[low], arr[high]), Math.max(arr[low], arr[high])];
    }
    
    const mid = Math.floor((low + high) / 2);
    const [min1, max1] = findMinMax(arr, low, mid);
    const [min2, max2] = findMinMax(arr, mid + 1, high);
    
    return [Math.min(min1, min2), Math.max(max1, max2)];
}

// 예시
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(findMinMax(arr, 0, arr.length - 1));  // [11, 90]
```

---

## 거듭제곱 계산

**시간복잡도**: O(log n) | **공간복잡도**: O(log n)

분할 정복으로 효율적인 거듭제곱 계산:

```javascript
function power(base, exp) {
    /**
     * base^exp 계산
     * O(log exp) 시간
     */
    if (exp === 0) {
        return 1;
    }
    
    if (exp % 2 === 0) {
        const half = power(base, Math.floor(exp / 2));
        return half * half;
    } else {
        return base * power(base, exp - 1);
    }
}

// 예시
console.log(power(2, 10));  // 1024
console.log(power(3, 5));   // 243
```

### 모듈로 거듭제곱

```javascript
function powerMod(base, exp, mod) {
    /**
     * (base^exp) % mod 계산
     * 큰 수 계산에 유용
     */
    let result = 1;
    base = base % mod;
    
    while (exp > 0) {
        if (exp % 2 === 1) {
            result = (result * base) % mod;
        }
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    
    return result;
}

// 예시
console.log(powerMod(2, 100, 1000000007));
```

---

## 행렬 곱셈

### Strassen 알고리즘

**시간복잡도**: O(n^2.807) (표준: O(n³))

```javascript
function matrixMultiplyNaive(A, B) {
    /**표준 행렬 곱셈 - O(n³)*/
    const n = A.length;
    const C = Array(n).fill(0).map(() => Array(n).fill(0));
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < n; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    
    return C;
}

function addMatrices(A, B) {
    const n = A.length;
    return A.map((row, i) => row.map((val, j) => val + B[i][j]));
}

function subtractMatrices(A, B) {
    const n = A.length;
    return A.map((row, i) => row.map((val, j) => val - B[i][j]));
}

function matrixMultiplyStrassen(A, B) {
    /**Strassen 알고리즘*/
    const n = A.length;
    
    // Base case
    if (n <= 64) {
        return matrixMultiplyNaive(A, B);
    }
    
    const mid = Math.floor(n / 2);
    
    // 행렬 분할
    const getQuadrant = (matrix, r, c) => {
        const result = [];
        for (let i = r; i < r + mid; i++) {
            result.push(matrix[i].slice(c, c + mid));
        }
        return result;
    };
    
    const A11 = getQuadrant(A, 0, 0);
    const A12 = getQuadrant(A, 0, mid);
    const A21 = getQuadrant(A, mid, 0);
    const A22 = getQuadrant(A, mid, mid);
    
    const B11 = getQuadrant(B, 0, 0);
    const B12 = getQuadrant(B, 0, mid);
    const B21 = getQuadrant(B, mid, 0);
    const B22 = getQuadrant(B, mid, mid);
    
    // 7개의 곱셈
    const M1 = matrixMultiplyStrassen(addMatrices(A11, A22), addMatrices(B11, B22));
    const M2 = matrixMultiplyStrassen(addMatrices(A21, A22), B11);
    const M3 = matrixMultiplyStrassen(A11, subtractMatrices(B12, B22));
    const M4 = matrixMultiplyStrassen(A22, subtractMatrices(B21, B11));
    const M5 = matrixMultiplyStrassen(addMatrices(A11, A12), B22);
    const M6 = matrixMultiplyStrassen(subtractMatrices(A21, A11), addMatrices(B11, B12));
    const M7 = matrixMultiplyStrassen(subtractMatrices(A12, A22), addMatrices(B21, B22));
    
    // 결과 행렬 조합
    const C11 = addMatrices(subtractMatrices(addMatrices(M1, M4), M5), M7);
    const C12 = addMatrices(M3, M5);
    const C21 = addMatrices(M2, M4);
    const C22 = addMatrices(subtractMatrices(addMatrices(M1, M3), M2), M6);
    
    // 합치기
    const C = [];
    for (let i = 0; i < mid; i++) {
        C.push([...C11[i], ...C12[i]]);
    }
    for (let i = 0; i < mid; i++) {
        C.push([...C21[i], ...C22[i]]);
    }
    
    return C;
}
```

---

## 분할 정복의 특징

| 측면 | 특징 |
|------|------|
| 시간 | 종종 O(n log n) |
| 공간 | 재귀 스택 필요 |
| 캐시 | 데이터 지역성 좋음 |
| 병렬화 | 용이 |
| 구현 | 복잡할 수 있음 |

## 분할 정복이 효과적인 경우

1. 문제를 독립적인 부분으로 분할 가능
2. 부분 문제의 크기가 비슷함
3. 문제의 크기가 충분히 큼 (오버헤드 고려)
4. 병렬 처리 가능함

