# 투 포인터/슬라이딩 윈도우 완전 가이드

## 목차
1. [투 포인터 기초](#투-포인터-기초)
2. [슬라이딩 윈도우](#슬라이딩-윈도우)
3. [고급 패턴](#고급-패턴)

---

## 투 포인터 기초

투 포인터는 배열이나 리스트에서 두 개의 포인터를 사용하여 효율적으로 탐색하는 기법입니다.

### 1. 정렬된 배열에서 합 찾기

**시간복잡도**: O(n) | **공간복잡도**: O(1)

```javascript
function twoSumSorted(arr, target) {
    /**
     * 정렬된 배열에서 합이 target인 두 수의 인덱스 찾기
     */
    let left = 0;
    let right = arr.length - 1;
    
    while (left < right) {
        const currentSum = arr[left] + arr[right];
        if (currentSum === target) {
            return [left, right];
        } else if (currentSum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return [];
}

// 예시
const arr = [2, 7, 11, 15];
const target = 9;
console.log(twoSumSorted(arr, target));  // [0, 1] (2+7=9)
```

### 2. 컨테이너에 담을 수 있는 최대 물의 양

```javascript
function maxArea(heights) {
    /**두 막대 사이의 최대 넓이 구하기*/
    let left = 0;
    let right = heights.length - 1;
    let maxArea = 0;
    
    while (left < right) {
        const width = right - left;
        const height = Math.min(heights[left], heights[right]);
        const area = width * height;
        maxArea = Math.max(maxArea, area);
        
        // 더 작은 높이 쪽을 이동
        if (heights[left] < heights[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxArea;
}

// 예시
const heights = [1, 8, 6, 2, 5, 4, 8, 3, 7];
console.log(maxArea(heights));  // 49
```

### 3. 정렬된 배열에서 중복 제거

```javascript
function removeDuplicates(arr) {
    /**정렬된 배열에서 중복 제거*/
    if (arr.length === 0) {
        return 0;
    }
    
    let left = 0;
    for (let right = 1; right < arr.length; right++) {
        if (arr[right] !== arr[left]) {
            left++;
            arr[left] = arr[right];
        }
    }
    
    return left + 1;
}

// 예시
const arr = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4];
const length = removeDuplicates(arr);
console.log(arr.slice(0, length));  // [0, 1, 2, 3, 4]
```

### 4. 3개 합 (3Sum)

**시간복잡도**: O(n²) | **공간복잡도**: O(1)

```javascript
function threeSum(arr, target) {
    /**배열에서 합이 target인 세 수 찾기*/
    arr.sort((a, b) => a - b);
    const n = arr.length;
    const result = [];
    
    for (let i = 0; i < n - 2; i++) {
        // 중복 방지
        if (i > 0 && arr[i] === arr[i - 1]) {
            continue;
        }
        
        let left = i + 1;
        let right = n - 1;
        
        while (left < right) {
            const currentSum = arr[i] + arr[left] + arr[right];
            if (currentSum === target) {
                result.push([arr[i], arr[left], arr[right]]);
                
                // 중복 건너뛰기
                while (left < right && arr[left] === arr[left + 1]) {
                    left++;
                }
                while (left < right && arr[right] === arr[right - 1]) {
                    right--;
                }
                
                left++;
                right--;
            } else if (currentSum < target) {
                left++;
            } else {
                right--;
            }
        }
    }
    
    return result;
}

// 예시
const arr = [-1, 0, 1, 2, -1, -4];
console.log(threeSum(arr, 0));  // [[-1, -1, 2], [-1, 0, 1]]
```

---

## 슬라이딩 윈도우

슬라이딩 윈도우는 고정 크기의 윈도우를 이동하면서 조건을 만족하는 구간을 찾습니다.

### 1. 부분 배열의 최대 합 (크기 k)

**시간복잡도**: O(n) | **공간복잡도**: O(1)

```javascript
function maxSumSubarray(arr, k) {
    /**크기 k인 부분 배열의 최대 합*/
    if (k > arr.length) {
        return null;
    }
    
    // 첫 윈도우의 합
    let windowSum = 0;
    for (let i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    let maxSum = windowSum;
    
    // 윈도우 이동
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}

// 예시
const arr = [1, 4, 2, 10, 2, 3, 1, 0, 20];
const k = 4;
console.log(maxSumSubarray(arr, k));  // 24
```

### 2. 최장 부분 문자열 (중복 없음)

**시간복잡도**: O(n) | **공간복잡도**: O(min(n, m))

```javascript
function longestSubstringWithoutRepeating(s) {
    /**중복 없는 최장 부분 문자열의 길이*/
    const charIndex = {};
    let maxLength = 0;
    let left = 0;
    
    for (let right = 0; right < s.length; right++) {
        const char = s[right];
        // 문자가 이미 윈도우에 있으면
        if (char in charIndex && charIndex[char] >= left) {
            left = charIndex[char] + 1;
        }
        
        charIndex[char] = right;
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}

// 예시
console.log(longestSubstringWithoutRepeating("abcabcbb"));  // 3
console.log(longestSubstringWithoutRepeating("bbbbb"));     // 1
console.log(longestSubstringWithoutRepeating("pwwkew"));    // 3
```

### 3. 최소 윈도우 부분 문자열

**시간복잡도**: O(n + m) | **공간복잡도**: O(m)

```javascript
function minWindowSubstring(s, t) {
    /**s에서 t의 모든 문자를 포함하는 최소 윈도우*/
    if (!s || !t) {
        return "";
    }
    
    const dictT = {};
    for (const char of t) {
        dictT[char] = (dictT[char] || 0) + 1;
    }
    
    const required = Object.keys(dictT).length;
    let left = 0, right = 0;
    let formed = 0;
    const windowCounts = {};
    const ans = [Infinity, null, null];
    
    while (right < s.length) {
        const char = s[right];
        windowCounts[char] = (windowCounts[char] || 0) + 1;
        
        if (char in dictT && windowCounts[char] === dictT[char]) {
            formed++;
        }
        
        // 조건을 만족하면 왼쪽을 이동
        while (left <= right && formed === required) {
            const char = s[left];
            
            if (right - left + 1 < ans[0]) {
                ans[0] = right - left + 1;
                ans[1] = left;
                ans[2] = right;
            }
            
            windowCounts[char]--;
            if (char in dictT && windowCounts[char] < dictT[char]) {
                formed--;
            }
            
            left++;
        }
        
        right++;
    }
    
    return ans[0] === Infinity ? "" : s.substring(ans[1], ans[2] + 1);
}

// 예시
const s = "ADOBECODEBANC";
const t = "ABC";
console.log(minWindowSubstring(s, t));  // "BANC"
```

### 4. 최대 문자 개수 (k 수정)

```javascript
function longestSubstringKDistinct(s, k) {
    /**최대 k개의 서로 다른 문자를 포함하는 최장 부분 문자열*/
    const charCount = {};
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        const char = s[right];
        charCount[char] = (charCount[char] || 0) + 1;
        
        // 서로 다른 문자가 k개를 초과하면
        while (Object.keys(charCount).length > k) {
            const leftChar = s[left];
            charCount[leftChar]--;
            if (charCount[leftChar] === 0) {
                delete charCount[leftChar];
            }
            left++;
        }
        
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}

// 예시
const s = "eceba";
const k = 2;
console.log(longestSubstringKDistinct(s, k));  // 3
```

---

## 고급 패턴

### 1. 가변 윈도우 (조건 변경)

```javascript
function maxOnesFlip(arr, k) {
    /**최대 k개의 0을 1로 바꾸어 연속 1의 최대 길이*/
    let left = 0;
    let zeroCount = 0;
    let maxLength = 0;
    
    for (let right = 0; right < arr.length; right++) {
        if (arr[right] === 0) {
            zeroCount++;
        }
        
        // 0의 개수가 k를 초과하면
        while (zeroCount > k) {
            if (arr[left] === 0) {
                zeroCount--;
            }
            left++;
        }
        
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}

// 예시
const arr = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0];
const k = 2;
console.log(maxOnesFlip(arr, k));  // 6
```

---

## 기법 선택 기준

| 상황 | 추천 기법 |
|------|---------|
| 정렬된 배열, 양쪽 탐색 | 투 포인터 |
| 고정 크기 윈도우 | 슬라이딩 윈도우 |
| 조건 만족 부분 배열 | 가변 윈도우 |
| 최대/최소 구간 찾기 | 슬라이딩 윈도우 |

---

## 시간복잡도 정리

- **투 포인터**: O(n) (정렬 후)
- **슬라이딩 윈도우**: O(n)
- **중첩 루프 제거 가능**: 최대 O(n²) → O(n)

