# 수학/정수론 완전 가이드

## 목차
1. [최대공약수와 최소공배수](#최대공약수와-최소공배수)
2. [소수 판별](#소수-판별)
3. [소인수분해](#소인수분해)
4. [모듈로 연산](#모듈로-연산)
5. [조합론](#조합론)

---

## 최대공약수와 최소공배수

### 유클리드 알고리즘 (GCD)

**시간복잡도**: O(log min(a, b))

```javascript
function gcd(a, b) {
    /**최대공약수 구하기 (반복)*/
    while (b !== 0) {
        [a, b] = [b, a % b];
    }
    return a;
}

// 재귀 방식
function gcdRecursive(a, b) {
    if (b === 0) {
        return a;
    }
    return gcdRecursive(b, a % b);
}

// 예시
console.log(gcd(48, 18));  // 6
console.log(gcd(100, 50));  // 50
```

### LCM (최소공배수)

```javascript
function lcm(a, b) {
    /**최소공배수*/
    return (a * b) / gcd(a, b);
}

// 예시
console.log(lcm(12, 18));  // 36
console.log(lcm(4, 6));    // 12
```

### 여러 수의 GCD/LCM

```javascript
function gcdMultiple(numbers) {
    /**여러 수의 최대공약수*/
    return numbers.reduce((a, b) => gcd(a, b));
}

function lcmMultiple(numbers) {
    /**여러 수의 최소공배수*/
    return numbers.reduce((a, b) => lcm(a, b));
}

// 예시
console.log(gcdMultiple([12, 18, 24]));  // 6
console.log(lcmMultiple([4, 6, 8]));     // 24
```

---

## 소수 판별

### 기본 방식

**시간복잡도**: O(√n)

```javascript
function isPrime(n) {
    /**기본적인 소수 판별*/
    if (n < 2) {
        return false;
    }
    if (n === 2) {
        return true;
    }
    if (n % 2 === 0) {
        return false;
    }
    
    for (let i = 3; i * i <= n; i += 2) {
        if (n % i === 0) {
            return false;
        }
    }
    return true;
}

// 예시
for (let i = 0; i < 20; i++) {
    if (isPrime(i)) {
        process.stdout.write(i + ' ');
    }
}
// 2 3 5 7 11 13 17 19
```

### 에라토스테네스의 체

**시간복잡도**: O(n log log n)

```javascript
function sieveOfEratosthenes(n) {
    /**n 이하의 모든 소수 반환*/
    const isPrime = new Array(n + 1).fill(true);
    isPrime[0] = isPrime[1] = false;
    
    for (let i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            // i의 배수들을 소수가 아니라 표시
            for (let j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    const primes = [];
    for (let i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push(i);
        }
    }
    return primes;
}

// 예시
console.log(sieveOfEratosthenes(30));
// [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

### Miller-Rabin 소수 판별

**시간복잡도**: O(k log n) (k는 반복 횟수)

큰 수의 소수 판별에 매우 효율적입니다.

```javascript
function isMillerRabin(n, k = 5) {
    /**Miller-Rabin 소수 판별법*/
    if (n < 2) {
        return false;
    }
    if (n === 2 || n === 3) {
        return true;
    }
    if (n % 2 === 0) {
        return false;
    }
    
    // n - 1 = 2^r * d 형태로 분해
    let r = 0, d = n - 1;
    while (d % 2 === 0) {
        r++;
        d = Math.floor(d / 2);
    }
    
    for (let i = 0; i < k; i++) {
        const a = 2 + Math.floor(Math.random() * (n - 3));
        let x = powerMod(a, d, n);
        
        if (x === 1 || x === n - 1) {
            continue;
        }
        
        let continueWLoop = false;
        for (let _ = 0; _ < r - 1; _++) {
            x = powerMod(x, 2, n);
            if (x === n - 1) {
                continueWLoop = true;
                break;
            }
        }
        
        if (!continueWLoop) {
            return false;
        }
    }
    
    return true;
}

function powerMod(base, exp, mod) {
    let result = 1;
    base = base % mod;
    
    while (exp > 0) {
        if (exp % 2 === 1) {
            result = (result * base) % mod;
        }
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    
    return result;
}

// 예시
console.log(isMillerRabin(17));     // true
console.log(isMillerRabin(561));    // false
```

---

## 소인수분해

**시간복잡도**: O(√n)

```javascript
function primeFactorization(n) {
    /**정수의 소인수분해*/
    const factors = [];
    
    // 2로 나누기
    while (n % 2 === 0) {
        factors.push(2);
        n = Math.floor(n / 2);
    }
    
    // 홀수로 나누기
    for (let i = 3; i * i <= n; i += 2) {
        while (n % i === 0) {
            factors.push(i);
            n = Math.floor(n / i);
        }
    }
    
    // n이 1보다 크면 그것도 소수
    if (n > 1) {
        factors.push(n);
    }
    
    return factors;
}

// 예시
console.log(primeFactorization(60));   // [2, 2, 3, 5]
console.log(primeFactorization(91));   // [7, 13]
```

### 고유 소인수와 개수

```javascript
function primeFactorizationDict(n) {
    /**소인수와 그 개수를 객체로 반환*/
    const factors = {};
    let d = 2;
    
    while (d * d <= n) {
        while (n % d === 0) {
            factors[d] = (factors[d] || 0) + 1;
            n = Math.floor(n / d);
        }
        d++;
    }
    
    if (n > 1) {
        factors[n] = (factors[n] || 0) + 1;
    }
    
    return factors;
}

// 예시
console.log(primeFactorizationDict(60));   // {2: 2, 3: 1, 5: 1}
console.log(primeFactorizationDict(100));  // {2: 2, 5: 2}
```

---

## 모듈로 연산

### 모듈로 거듭제곱

**시간복잡도**: O(log n)

```javascript
function powerMod(base, exp, mod) {
    /**
     * (base^exp) % mod 계산 - 큰 수 처리
     */
    let result = 1;
    base = base % mod;
    
    while (exp > 0) {
        if (exp % 2 === 1) {
            result = (result * base) % mod;
        }
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    
    return result;
}

// 예시
console.log(powerMod(2, 100, 1000000007));  // 976371285
console.log(powerMod(10, 100, 13));         // 1
```

### 모듈로 역원

```javascript
function extendedGCD(a, b) {
    /**확장 유클리드 알고리즘*/
    if (a === 0) {
        return [b, 0, 1];
    }
    const [gcd, x1, y1] = extendedGCD(b % a, a);
    const x = y1 - Math.floor(b / a) * x1;
    const y = x1;
    return [gcd, x, y];
}

function modInverse(a, m) {
    /**
     * 모듈로 역원: a * x ≡ 1 (mod m)을 만족하는 x
     * gcd(a, m) = 1 일 때만 존재
     */
    const [gcd, x] = extendedGCD(a % m, m);
    if (gcd !== 1) {
        return null;  // 역원 존재하지 않음
    }
    return (x % m + m) % m;
}

// 예시
console.log(modInverse(3, 11));  // 4 (3*4 = 12 ≡ 1 mod 11)
console.log(modInverse(7, 26));  // 15
```

---

## 조합론

### 순열과 조합

```javascript
function factorial(n) {
    /**n! 계산*/
    if (n <= 1) {
        return 1;
    }
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

function permutation(n, r) {
    /**P(n, r) = n! / (n-r)!*/
    if (r > n) {
        return 0;
    }
    return factorial(n) / factorial(n - r);
}

function combination(n, r) {
    /**C(n, r) = n! / (r! * (n-r)!)*/
    if (r > n) {
        return 0;
    }
    return factorial(n) / (factorial(r) * factorial(n - r));
}

// 예시
console.log(permutation(5, 2));   // 20
console.log(combination(5, 2));   // 10
```

### 파스칼의 삼각형 (DP)

**시간복잡도**: O(n²) | **공간복잡도**: O(n²)

```javascript
function combinationDP(n, r) {
    /**DP를 이용한 조합 계산*/
    const dp = Array(n + 1).fill(0).map(() => Array(r + 1).fill(0));
    
    for (let i = 0; i <= n; i++) {
        dp[i][0] = 1;
        for (let j = 1; j <= Math.min(i, r); j++) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        }
    }
    
    return dp[n][r];
}

// 예시
console.log(combinationDP(10, 3));  // 120
```

### 모듈로 조합

```javascript
function combinationMod(n, r, mod) {
    /**C(n, r) % mod 계산*/
    if (r > n) {
        return 0;
    }
    if (r === 0 || r === n) {
        return 1;
    }
    
    // 분자 계산
    let numerator = 1;
    for (let i = n; i > n - r; i--) {
        numerator = (numerator * i) % mod;
    }
    
    // 분모 계산
    let denominator = 1;
    for (let i = 1; i <= r; i++) {
        denominator = (denominator * i) % mod;
    }
    
    // 역원을 이용한 나눗셈
    return (numerator * modInverse(denominator, mod)) % mod;
}

// 예시 (mod가 소수일 때)
console.log(combinationMod(10, 3, 1000000007));
```

