# 스택/큐/덱 완전 가이드

## 목차
1. [스택 (Stack)](#스택-stack)
2. [큐 (Queue)](#큐-queue)
3. [덱 (Deque)](#덱-deque)
4. [우선순위 큐](#우선순위-큐)
5. [응용 문제들](#응용-문제들)

---

## 스택 (Stack)

**특징**: LIFO (Last In First Out)
**시간복잡도**: Push/Pop/Peek O(1) | **공간복잡도**: O(n)

### 배열 기반 구현

```javascript
class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        /**스택에 아이템 추가*/
        this.items.push(item);
    }
    
    pop() {
        /**스택에서 아이템 제거 및 반환*/
        if (!this.isEmpty()) {
            return this.items.pop();
        }
        return null;
    }
    
    peek() {
        /**맨 위 아이템 조회 (제거 안 함)*/
        if (!this.isEmpty()) {
            return this.items[this.items.length - 1];
        }
        return null;
    }
    
    isEmpty() {
        /**스택이 비었는지 확인*/
        return this.items.length === 0;
    }
    
    size() {
        /**스택의 크기*/
        return this.items.length;
    }
}

// 예시
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.pop());    // 3
console.log(stack.peek());   // 2
```

### 괄호 매칭 문제

```javascript
function isValidParentheses(s) {
    /**괄호가 올바르게 매칭되었는지 확인*/
    const stack = [];
    const pairs = {')': '(', '}': '{', ']': '['};
    
    for (const char of s) {
        if (char in pairs) {
            // 닫는 괄호
            if (!stack.length || stack[stack.length - 1] !== pairs[char]) {
                return false;
            }
            stack.pop();
        } else {
            // 열는 괄호
            stack.push(char);
        }
    }
    
    return stack.length === 0;
}

// 예시
console.log(isValidParentheses("()[]{}"));      // true
console.log(isValidParentheses("([{}])"));      // true
console.log(isValidParentheses("([)]"));        // false
```

### 후위 표기법 (Postfix Notation)

```javascript
function evaluatePostfix(expression) {
    /**후위 표기법 수식 계산*/
    const stack = [];
    const tokens = expression.split(' ');
    const operators = {'+': 1, '-': 1, '*': 2, '/': 2};
    
    for (const token of tokens) {
        if (token in operators) {
            // 연산자: 스택에서 두 개 꺼내기
            if (stack.length < 2) {
                return null;
            }
            const b = stack.pop();
            const a = stack.pop();
            
            let result;
            if (token === '+') {
                result = a + b;
            } else if (token === '-') {
                result = a - b;
            } else if (token === '*') {
                result = a * b;
            } else if (token === '/') {
                result = Math.floor(a / b);
            }
            
            stack.push(result);
        } else {
            // 숫자: 스택에 넣기
            stack.push(parseInt(token));
        }
    }
    
    return stack[0];
}

// 예시
console.log(evaluatePostfix("3 4 +"));           // 7
console.log(evaluatePostfix("3 4 + 2 *"));       // 14
```

---

## 큐 (Queue)

**특징**: FIFO (First In First Out)
**시간복잡도**: Enqueue/Dequeue O(1) | **공간복잡도**: O(n)

### 직접 구현

```javascript
class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        /**큐에 아이템 추가*/
        this.items.push(item);
    }
    
    dequeue() {
        /**큐에서 아이템 제거 및 반환*/
        if (!this.isEmpty()) {
            return this.items.shift();
        }
        return null;
    }
    
    front() {
        /**맨 앞 아이템 조회*/
        if (!this.isEmpty()) {
            return this.items[0];
        }
        return null;
    }
    
    isEmpty() {
        /**큐가 비었는지 확인*/
        return this.items.length === 0;
    }
    
    size() {
        /**큐의 크기*/
        return this.items.length;
    }
}

// 예시
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
console.log(queue.dequeue());  // 1
console.log(queue.front());    // 2
```

### 순환 큐 (원형 큐)

```javascript
class CircularQueue {
    constructor(capacity) {
        this.capacity = capacity;
        this.items = new Array(capacity);
        this.frontIdx = 0;
        this.rearIdx = -1;
        this.size = 0;
    }
    
    enqueue(item) {
        /**아이템 추가*/
        if (this.size === this.capacity) {
            return false;  // 큐가 가득 참
        }
        
        this.rearIdx = (this.rearIdx + 1) % this.capacity;
        this.items[this.rearIdx] = item;
        this.size++;
        return true;
    }
    
    dequeue() {
        /**아이템 제거*/
        if (this.size === 0) {
            return null;
        }
        
        const item = this.items[this.frontIdx];
        this.frontIdx = (this.frontIdx + 1) % this.capacity;
        this.size--;
        return item;
    }
    
    isEmpty() {
        return this.size === 0;
    }
}

// 예시
const cq = new CircularQueue(5);
for (let i = 0; i < 5; i++) {
    cq.enqueue(i);
}
console.log(cq.dequeue());  // 0
```

---

## 덱 (Deque)

**특징**: 양쪽 끝에서 삽입/삭제 가능
**시간복잡도**: O(1) | **공간복잡도**: O(n)

```javascript
class Deque {
    constructor() {
        this.items = [];
    }
    
    addFront(item) {
        /**앞에 추가*/
        this.items.unshift(item);
    }
    
    addRear(item) {
        /**뒤에 추가*/
        this.items.push(item);
    }
    
    removeFront() {
        /**앞에서 제거*/
        if (!this.isEmpty()) {
            return this.items.shift();
        }
        return null;
    }
    
    removeRear() {
        /**뒤에서 제거*/
        if (!this.isEmpty()) {
            return this.items.pop();
        }
        return null;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

// 예시
const dq = new Deque();
dq.addFront(1);
dq.addRear(2);
dq.addFront(0);
console.log(dq.removeFront());  // 0
console.log(dq.removeRear());   // 2
```

### 슬라이딩 윈도우 (최댓값)

```javascript
function maxSlidingWindow(arr, k) {
    /**크기 k인 윈도우에서 최댓값을 모두 찾기*/
    const deq = [];
    const result = [];
    
    for (let i = 0; i < arr.length; i++) {
        // 윈도우 범위 벗어난 인덱스 제거
        while (deq.length && deq[0][1] < i - k + 1) {
            deq.shift();
        }
        
        // 새로운 원소보다 작은 원소들 제거
        while (deq.length && deq[deq.length - 1][0] < arr[i]) {
            deq.pop();
        }
        
        deq.push([arr[i], i]);
        
        if (i >= k - 1) {
            result.push(deq[0][0]);
        }
    }
    
    return result;
}

// 예시
const arr = [1, 3, -1, -3, 5, 3, 6, 7];
const k = 3;
console.log(maxSlidingWindow(arr, k));  // [3, 3, 5, 5, 6, 7]
```

---

## 우선순위 큐

### JavaScript 배열 기반 구현

```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this._bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._bubbleDown(0);
        return min;
    }
    
    _bubbleUp(idx) {
        while (idx > 0) {
            const parentIdx = Math.floor((idx - 1) / 2);
            if (this.heap[parentIdx] <= this.heap[idx]) break;
            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];
            idx = parentIdx;
        }
    }
    
    _bubbleDown(idx) {
        while (true) {
            let smallest = idx;
            const left = 2 * idx + 1;
            const right = 2 * idx + 2;
            
            if (left < this.heap.length && this.heap[left] < this.heap[smallest]) {
                smallest = left;
            }
            if (right < this.heap.length && this.heap[right] < this.heap[smallest]) {
                smallest = right;
            }
            if (smallest === idx) break;
            
            [this.heap[smallest], this.heap[idx]] = [this.heap[idx], this.heap[smallest]];
            idx = smallest;
        }
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
}

// 예시
const minHeap = new MinHeap();
minHeap.push(5);
minHeap.push(3);
minHeap.push(7);
minHeap.push(1);
console.log(minHeap.pop());  // 1
```

---

## 응용 문제들

### 다음 더 큰 원소 (Next Greater Element)

```javascript
function nextGreaterElement(arr) {
    /**각 원소의 오른쪽에서 더 큰 원소 찾기*/
    const result = new Array(arr.length).fill(-1);
    const stack = [];
    
    for (let i = arr.length - 1; i >= 0; i--) {
        // 스택에서 현재 원소보다 작은 것들 제거
        while (stack.length && stack[stack.length - 1] <= arr[i]) {
            stack.pop();
        }
        
        if (stack.length) {
            result[i] = stack[stack.length - 1];
        }
        
        stack.push(arr[i]);
    }
    
    return result;
}

// 예시
const arr = [1, 5, 0, 3, 4, 5];
console.log(nextGreaterElement(arr));  // [5, -1, 3, 4, 5, -1]
```

### 가장 큰 직사각형 (Largest Rectangle in Histogram)

```javascript
function largestRectangle(heights) {
    /**히스토그램에서 가장 큰 직사각형의 넓이*/
    const stack = [];
    let maxArea = 0;
    let index = 0;
    
    while (index < heights.length) {
        if (!stack.length || heights[index] >= heights[stack[stack.length - 1]]) {
            stack.push(index);
            index++;
        } else {
            const top = stack.pop();
            const width = stack.length ? index - stack[stack.length - 1] - 1 : index;
            const area = heights[top] * width;
            maxArea = Math.max(maxArea, area);
        }
    }
    
    while (stack.length) {
        const top = stack.pop();
        const width = stack.length ? index - stack[stack.length - 1] - 1 : index;
        const area = heights[top] * width;
        maxArea = Math.max(maxArea, area);
    }
    
    return maxArea;
}

// 예시
const heights = [2, 1, 5, 6, 2, 3];
console.log(largestRectangle(heights));  // 10
```

---

## 성능 비교

| 자료구조 | Push | Pop | Peek | 특징 |
|---------|------|-----|------|------|
| Stack | O(1) | O(1) | O(1) | LIFO |
| Queue | O(1) | O(1) | O(1) | FIFO |
| Deque | O(1) | O(1) | O(1) | 양쪽 |
| Heap | O(log n) | O(log n) | O(1) | 정렬됨 |

## 선택 기준

- **스택**: 괄호, 함수 호출, DFS
- **큐**: BFS, 작업 스케줄링, 메시지 처리
- **덱**: 슬라이딩 윈도우, 양방향 탐색
- **우선순위 큐**: 다익스트라, 힙 정렬, Top K

